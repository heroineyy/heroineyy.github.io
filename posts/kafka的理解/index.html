<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是一个个人博客，记录技术学习和生活感悟"><title>Kafka的理解？ | RenaXu 's Wonderland</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/custom-icons.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/toc.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kafka的理解？</h1><a id="logo" href="/.">RenaXu 's Wonderland</a><p class="description">分享技术与生活</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">Kafka的理解？</h1><div class="post-meta">2025-10-07<span> | </span><span class="category"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 5</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">kafka有几个关键的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">为什么要这么设计？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">还有意思的是消费者这边的设计。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Kafka 是怎么解决消费失败后可重复消费的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">另外高频的kafka考点是，如何保证顺序消费？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Kafka 如何高效管理海量数据，面对 TB 级数据，它如何做到 “快速写入 + 快速查询”？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">关于kafka集群的管理，原来使用的Zookeeper是怎么感知kafka集群的变化的?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">升级后的Kraft，是怎么管理kafka的集群的？</span></a></li></ol></div></div><div class="post-content"><p>Kafka 本质上是一个消息队列中间件，经常在高并发的场景下我们会见到它，那顾名思义它就是面向于高并发的场景。下面我们来简单了解一下它吧～</p>
<h1><span id="kafka有几个关键的概念">kafka有几个关键的概念</span></h1><p>既然是消息队列，那么一定包含生产者和消费者：</p>
<p>每个生产者生产的消息都会属于一个topic,同一个topic的消息们会按照策略被分到不同的分区（partion）中，为了高可用，每个topic的多个partion都会有副本，将会存到不同的broker上，broker可以看作是服务器，它可以有多个话题的partion,可以从下图中看出他们的关系：    </p>
<p><img src="/images/image-20251001152947442.png" alt="image-20251001152947442"></p>
<h1><span id="为什么要这么设计">为什么要这么设计？</span></h1><p>首先多副本可以保证改可用性，即使当前brocker挂了，也会在其他brocker里面找到对应的副本恢复，并将副本所在的节点转换成主节点。</p>
<p>其次topic的消息的存放分到多个partion，实现负载均衡，分摊单个服务器的存储压力。</p>
<h1><span id="还有意思的是消费者这边的设计">还有意思的是消费者这边的设计。</span></h1><p>为了增大吞吐量，引入消费者组，消费者组内成员不能消费同一条消息，消费者组可以订阅多个topic,；</p>
<p>为了使多个消费者可以消费同一条消息，这里针对消费者组在分区引入各个消费组的偏移量，这样即使消费组的成员消费了，也不会影响其他消费组的消费者成员消费（解决重复消费的问题）即：</p>
<p><strong>同一消费者组内 “分工消费”（1 个分区仅被 1 个消费者消费）</strong>，本质是通过 “分区重平衡（Rebalance）” 机制，让组内消费者公平分配 Topic 的分区，确保 “分区 - 消费者” 的唯一映射。</p>
<p><strong>不同消费者组 “重复消费” 同一 Topic</strong>，核心是 <strong>“消费进度（Offset）按组隔离”</strong>，每个组独立记录自己的消费位置，互不干扰。</p>
<p>简单总结：</p>
<ul>
<li>对内（同组）：<strong>“分任务，提效率”</strong>（不重复、高吞吐）。</li>
<li>对外（跨组）：<strong>“多副本，保灵活”</strong>（可重复、多场景）。</li>
</ul>
<h1><span id="kafka-是怎么解决消费失败后可重复消费的">Kafka 是怎么解决消费失败后可重复消费的？</span></h1><p>核心本质是：通过消费者自主管理偏移量（Offset）。当消费失败时，消费者不提交当前偏移量，下次消费会从上次提交的偏移量重新开始，从而实现消息重消费。消息是否保留由过期时间等规则决定，但重复消费的关键是偏移量未提交，而非消息未删除。</p>
<h1><span id="另外高频的kafka考点是如何保证顺序消费">另外高频的kafka考点是，如何保证顺序消费？</span></h1><p>对于生产者，每条消息是追加写的都有分配的递增序号；</p>
<p>对于消费者来说，通过偏移量标识已经消费的消息偏移量。</p>
<p>简单总结一下即为：</p>
<p>写入时有序：分区的日志结构（追加写）决定了消息在分区内天然有序，Offset 是有序性的 “序号标识”。</p>
<p>消费时有序：1）消费者必须按 Offset 递增顺序读取；2）消费者组机制确保一个分区仅被一个消费者消费，避免多消费者并发处理导致的乱序。</p>
<h1><span id="kafka-如何高效管理海量数据面对-tb-级数据它如何做到-快速写入-快速查询">Kafka 如何高效管理海量数据，面对 TB 级数据，它如何做到 “快速写入 + 快速查询”？</span></h1><p>Kafka 记录消息时，会按<strong>分区 + Offset 顺序</strong>将消息追加到分段的日志文件（.log）中（顺序写入避免随机 IO，保证快速写入）；同时，会为每个日志分段生成对应的索引文件（.index），记录 “消息 Offset 与它在.log 文件中的物理位置（如字节偏移量）” 的映射关系。</p>
<p>后续查询时，无需扫描全量日志，只需先通过索引文件快速定位到目标消息所在的分段和具体物理位置，再直接读取.log 文件中的数据，从而实现海量数据下的快速查找。</p>
<h1><span id="关于kafka集群的管理原来使用的zookeeper是怎么感知kafka集群的变化的">关于kafka集群的管理，原来使用的Zookeeper是怎么感知kafka集群的变化的?</span></h1><p>核心是 “<strong>节点主动注册 + 连接断连感知 + 变化通知</strong>”：</p>
<ol>
<li>Kafka 的 Broker、消费者等节点启动时，会主动在 Zookeeper 上创建节点（ Broker 对应临时节点），把自己的信息注册上去；</li>
<li>其他 Kafka 节点会监听Zookeeper 的这些注册路径；</li>
<li>若某个 Kafka 节点挂了，它和 Zookeeper 的网络连接断开，对应的注册节点会自动消失，Zookeeper 会立刻把 “节点消失” 的消息通知给所有监听的节点；</li>
<li>收到通知的节点就知道集群有变化，进而触发后续操作（比如重新选 Leader、分配分区）。</li>
</ol>
<p>Zookeeper 感知 Kafka 集群变化的核心，是<strong>用 “临时节点” 绑定 Kafka 组件的生命周期（组件活则节点在，组件死则节点删），用 “事件监听” 实现 “变化主动通知”</strong>—— 无需 Kafka 组件频繁查询 Zookeeper，而是由 Zookeeper 在变化发生时 “推消息”，从而实现高效、实时的集群状态感知。</p>
<h1><span id="升级后的kraft是怎么管理kafka的集群的">升级后的Kraft，是怎么管理kafka的集群的？</span></h1><p>Kraft 就是让 Kafka 自己的节点分工合作，用 Raft 算法保证 “领导组” 决策一致，靠内部直接通信替代 Zookeeper 的外部协调，从而更高效、更稳定。</p>
<p>首先在Kafka集群中，分为controller和broker两个角色，controller用于元数据管理和更新，其中包含主controller和从controller，主 Controller 是通过 Raft 协议从 Controller 节点组中选举产生的，且所有元数据变更（如创建 Topic、Leader 切换）必须经过主 Controller 处理，并同步到多数从 Controller 后才生效（Raft 的 “多数确认” 机制）。这保证了元数据的一致性，避免了单节点故障导致的决策混乱 。</p>
<p>broker负责消息的的存储和交互，他的元数据来源于controller，每个broker的元数据都会保持最终一致，无论是消费者还是生产者都会在消费消息或者生产消息的时候随机选取一个broker节点获取元数据然后读写消息。</p>
<p>另外消费者组的信息（如消费进度、分区分配）会作为元数据被 Controller 管理，通过注册信息以保证消费连续性。生产者仅作为 “消息发送者”，无需在集群中留下持久化信息。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li></ul></div><div class="post-nav"><a class="pre" href="/posts/%E4%B8%87%E7%B1%B3%E8%B7%91%E5%90%8E%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/">万米跑后的流水账</a><a class="next" href="/posts/GMP%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/">GMP模型的理解</a></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">RenaXu 's Wonderland.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script></div></body></html>