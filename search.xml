<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cursor meetup chengdu的一些感受</title>
    <url>/posts/Cursor%20meetup%20chengdu%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97/</url>
    <content><![CDATA[<h2><span id="一-leerob的分享">一、leerob的分享</span></h2><p>1、知道所以然 基础知识 底层原理</p>
<p>2、一定要尝试并体验新技术</p>
<p>3、一定要经历挫折</p>
<p>4、解决幻觉，事先把设计系统、应用架构环境告诉给AI</p>
<p>5、深入理解mcp 才能使用mcp</p>
<p>6、去<a href="http://x.com/">x.com</a>社交软件看看leerob的上下文原理（多到不同平台看看大佬的对新技术的理解和观点）</p>
<h2><span id="二-分享会的有趣信息">二、分享会的有趣信息</span></h2><p>1、项目很大的话 上下文太多 大模型出现问题怎么办？可以让gpt对代码进行拆分</p>
<p>2、阅读代码 ，可以把函数给gpt总结核心、抽取主干再阅读</p>
<p>3、让大模型生成测试数据，根据示例数据生成回答</p>
<p>4、cursor 最适合写工具类和单元测试代码</p>
<p>5、写代码前，提前告诉他环境版本信息，避免写出和当前环境不匹配，导致运行不通过的代码 </p>
<p>6、一些推荐技术或工具网站分享</p>
<p>1）difi-on-qianniu</p>
<p>2）vercel</p>
<p>3）monica</p>
<p>4）deep-wiki（将代码库发给他生成详细的文档）</p>
<h2><span id="三-自由交流时间的收获">三、自由交流时间的收获</span></h2><p>1、先修心再修术</p>
<p>2、找不到目标？找到一个技能树，把它填满</p>
<p>3、当下学习什么？拥抱新技术、大胆尝试、但依旧要深挖底层基础，啃大骨头才是我们程序员的核心竞争力</p>
<p>4、简历被拒，面试没有通过？针对找后端项目，可能是项目太过简单面试官看不上，那么就打磨技术多写代码，对自己的项目做进一步优化，事实求是，另外回答问题不笃定出现了“吧”什么的只是面试的大忌，不要把面试官当成傻子，包装的简历一定会被洞察到，写到简历的东西一定要熟悉。</p>
<p>5、关于提升后端技能</p>
<p>首次从工作上面考虑：</p>
<p>1）在工作中想想哪些是重复的工作，哪些环节需要优化、沿着工作的技术做衍生学习 </p>
<p>2）把握时代的风口，提前学小而精的东西，大家都不学或不知道然后你去学的东西，做到60%～70%，取得老板信任将其工作交付于你负责（学习领导里感觉也很重要）</p>
<p>其次从下班后上考虑：</p>
<p>1）找到一个技能树，设定短期目标、一点点把它填满，</p>
<p>2）如何在这个过程取得正反馈？任务拆解，选择自己感兴趣的学习</p>
<p>6、一切皆有可能，向外寻求机会、找到一切可能性、多分享多连接</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Git合并冲突解决与操作逻辑（AI版）</title>
    <url>/posts/Git%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91%EF%BC%88AI%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>基于自己的思考结合AI给我梳理的总结，强烈建议看，真的非常条理性，易读也易懂。</p>
</blockquote>
<p>在多人协作的 Git 开发流程中，代码冲突是不可避免的场景。如何优雅地解决冲突并确保本地修改不丢失，需要一套清晰的操作逻辑。以下是对冲突解决思路的梳理与优化：</p>
<h3><span id="一-冲突场景的核心矛盾">一、冲突场景的核心矛盾</span></h3><p>当多人基于同一分支开发时，若远程分支已存在他人提交的新内容，而你的本地修改基于旧版本进行，此时无论是直接 <code>git push</code>（因版本不一致被拒绝），还是先 <code>git pull</code> 再提交（触发合并冲突），都会面临冲突问题。核心矛盾在于：<strong>本地修改与远程最新版本存在差异，需要通过合并整合，但过程中需避免本地内容意外丢失</strong>。</p>
<h3><span id="二-两种经典解决方案的细节与适用场景">二、两种经典解决方案的细节与适用场景</span></h3><p>针对不同开发状态（如代码是否完成、是否愿意提交半成品），可采用以下两种方案：</p>
<h4><span id="方案一用-git-stash-暂存中间状态推荐未完成开发时使用">方案一：用 <code>git stash</code> 暂存中间状态（推荐未完成开发时使用）</span></h4><p><strong>操作流程</strong>：</p>
<p><code>git stash</code> → <code>git pull</code> → <code>git stash pop</code> → 解决冲突 → <code>git add</code> → <code>git commit</code> → <code>git push</code></p>
<p><strong>核心原理</strong>：</p>
<ol>
<li><code>git stash</code> 会将<strong>工作区和暂存区的所有修改</strong>（包括未提交的代码）临时保存到 Git 的「 stash 栈」中，并将工作区和暂存区恢复到本地最近一次提交的干净状态。若需保存未跟踪的文件（如新建但未 <code>git add</code> 的文件），可使用 <code>git stash -u</code>（<code>-u</code> 即 <code>--include-untracked</code>）。</li>
<li><code>git pull</code> 此时可顺利拉取远程最新代码（因本地已无未提交修改，避免了合并冲突的前置阻碍）。</li>
<li><code>git stash pop</code> 将暂存的修改恢复到工作区，此时本地代码相当于「远程最新版本 + 你的本地修改」，若存在冲突，Git 会在工作区标记冲突位置。</li>
<li>手动解决冲突后，通过 <code>git add</code> 和 <code>git commit</code> 整合修改，最终推送到远程。</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li><p>无需提交「半成品代码」，保持提交记录的整洁性（最终仅生成一次包含完整修改的提交）。</p>
</li>
<li><p>适合开发到中途需同步远程代码的场景，既保证本地修改不丢失，又能基于最新版本继续开发。</p>
</li>
</ul>
<h4><span id="方案二先提交本地修改再合并远程代码推荐已完成开发时使用">方案二：先提交本地修改，再合并远程代码（推荐已完成开发时使用）</span></h4><p><strong>操作流程</strong>：</p>
<p><code>git add .</code> → <code>git commit -m &quot;描述修改内容&quot;</code> → <code>git pull</code> → 解决冲突 → <code>git add</code> → <code>git commit</code> → <code>git push</code></p>
<p><strong>核心原理</strong>：</p>
<ol>
<li><p>先通过 <code>git commit</code> 将本地修改固化为一个正式版本，确保工作区和暂存区干净。</p>
</li>
<li><p><code>git pull</code> 实际包含 <code>git fetch</code>（拉取远程最新提交记录到本地）和 <code>git merge</code>（将本地提交与远程最新版本合并）：</p>
</li>
</ol>
<ul>
<li><p>若合并无冲突，Git 会自动生成一个「合并提交」，整合双方修改。</p>
</li>
<li><p>若有冲突，Git 会在工作区标记冲突文件，需手动解决后再次提交。</p>
</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li><p>步骤直观，适合已完成开发、确认本地修改无误的场景。</p>
</li>
<li><p>所有修改都有明确的提交记录，便于后续追溯和回滚。</p>
</li>
</ul>
<h3><span id="三-关键原则避免冲突的核心是及时同步">三、关键原则：避免冲突的核心是「及时同步」</span></h3><p>无论采用哪种方案，核心逻辑都是<strong>让本地修改基于远程最新版本进行整合</strong>。冲突的本质是「同一部分代码被多人修改」，因此：</p>
<ol>
<li><p>开发过程中应频繁 <code>git pull</code> 同步远程更新，减少冲突概率；</p>
</li>
<li><p>解决冲突时需仔细比对双方修改，确保业务逻辑正确；</p>
</li>
<li><p>永远不要用 <code>--force</code> 强制推送（可能覆盖他人代码），除非明确知道自己在做什么。</p>
</li>
</ol>
<h3><span id="总结">总结</span></h3><p>冲突是 Git 协作的正常现象，两种方案各有侧重：</p>
<ul>
<li><p>未完成开发时，用 <code>git stash</code> 暂存修改，同步后继续开发，保持提交整洁；</p>
</li>
<li><p>已完成开发时，先提交本地修改，再合并远程更新，明确记录变更。</p>
</li>
</ul>
<p>记住：<strong>冲突一定可以解决，关键是通过规范操作避免内容丢失</strong>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go哲学</title>
    <url>/posts/Go%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[<p>1、Go 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 Goroutine 当作免费的资源，随便用。</p>
<p>2、Go 的并发编程模型用 Goroutine 和 Channel 来替代。Goroutine 和线程类似，Channel 和 Mutex 类似。</p>
<p>3、Channel 的发送和接收操作本质上都是 “值的拷贝”。</p>
<p>4、Go 的理念：用通信来共享内存。与其让多个 Goroutine 争抢同一块内存，不如让它们各自独立，通过 Channel 把需要的数据传递给对方，核心目的是避免数据竞争。</p>
<p>5、Go 参数传递都是值传递。</p>
<p>6、&amp;和*的区别</p>
<ul>
<li><p>&amp;是引用，作用于值类型，用于取地址，如果想要传递一个类型的地址避免值拷贝，就可以在前面加一个&amp;表示取该类型的地址，在函数的参数定义时，记得在参数的类型加上*。</p>
</li>
<li><p>*是指针，用于标记指针类型，或者对地址进行解引用，例如 var a *int  中，a 为指向 int 类型的地址， 若 p 是的类型是指针，*p 表示地址 p 指向的值。</p>
</li>
</ul>
<p>7、GMP 模型</p>
<p>M，内核线程，操作系统内核其实看不见 G 和 P，只知道自己在执行一个线程。G 和 P 都是在用户空间上的实现。每一个 M 持有一个 P，通过 P 来获取 G。</p>
<p>8、Go 语言在高并发场景应用非常广泛，但是 Go 的数据结构大多数都是线程不安全的，也就是说当多个 groutine 同时操作数据会存在数据竞争的问题，比如 Map、Chan 线程并不安全，解决方案可以加锁也可以用好 channel，本质需要通过 synic.lock 来应对并发问题使其同一时间保证只有一个协程用一份数据。</p>
<p>9、组合优于继承，通过 “结构体嵌入”（Struct Embedding）实现代码复用和功能组合。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd与redis的特性解析</title>
    <url>/posts/etcd%E4%B8%8Eredis%E7%9A%84%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>为什么写这个，因为感觉这玩意官方写得不太明白，所以想用更为通俗易懂的方式写清楚这是什么，看得愉快~</p>
</blockquote>
<h1><span id="关于etcd">关于etcd</span></h1><p>etcd 官方对它的定义是：一个<strong>高度一致的分布式键值存储系统</strong>，能为分布式系统或机器集群提供可靠的数据存储服务。它的厉害之处在于，即便遇到网络分区，也能优雅地完成领导者选举，而且机器故障也不怕，哪怕是领导者节点出问题也能应对。​</p>
<p>咱们先拆拆 “分布式” 这三个字。etcd 可以由很多节点组成一个集群，最关键的是，每个节点存储的信息都高度一致。再看 “键值存储系统”，这说明它和 redis 本质上是一类东西，都是用来存键值对的。但两者的区别也很明显，<strong>etcd 主打的就是 “高度一致” 和 “分布式”</strong>，而 redis 集群里每个节点的信息并不完全相同。​</p>
<p>更具体地说，<strong>redis 是基于内存进行读写的，这就让它特别适合高并发的场景</strong>；而 etcd 则更适合对一致性要求高的分布式场景。​</p>
<p>etcd 能保证节点一致性，靠的是<strong>raft 算法</strong>。这个算法把节点分成了三类：领导者、追随者和候选人。领导者的职责很明确，负责处理写数据的请求，还得和追随者保持通信；追随者主要是处理客户端的读请求；候选人呢，就是未来有可能成为领导者的节点。</p>
<p><strong>那一致性是怎么保证的？</strong> 简单说，就是要让追随者的数据和领导者保持一致，这是通过追随者向领导者发起心跳来实现的。有了心跳，领导者就能和追随者保持连接，一旦有新数据，就能随时通知追随者同步。当追随者处理客户端的读请求时，它会在领导者给的租期时间内完成操作，要是超过租期，就会主动和领导者通信，确保拿到的数据是最新的，这样就不会把脏数据返回给客户端了。​</p>
<h1><span id="关于redis">关于redis</span></h1><p>主要提提 redis 的一个重要概念 —— 分布式锁。​</p>
<p>首先，<strong>什么是分布式锁？</strong> 它是专门用在分布式场景下的锁，能保证在分布式环境中，多个服务同时只能有一个拿到这把锁。这好处可不小，在高并发环境里，能确保同一时间只有一个服务能访问特定的共享资源，从而避免出现竞态条件和数据不一致的问题。​</p>
<p>那 <strong>redis的应用场景有哪些？</strong> 比如在高并发请求中，能保证多个请求同时到来时，对数据的更改不会出错；还能用来限流，保护服务器的高可用性。​</p>
<p><strong>为什么 redis 能实现分布式锁？</strong> 因为 Redis 的SETNX 命令是原子操作。在并发情况下，这个命令能保证只有一个客户端能成功设置锁，也就是说，只有一个服务能获得锁。一旦锁被创建，其他客户端就不能重复创建了。​<strong>具体操作</strong> 起来是这样的：一个服务要访问共享资源时，会先检查锁对应的键是否存在。如果存在，说明已经有服务在访问了，那它就不能再访问，得等着锁被释放；如果不存在，就会创建这个键，也就是拿到锁，然后去访问资源，访问完再把键删掉，释放锁。另外，在分布式场景里，不管 redis 是作为集群还是单体存在，它都是独立于每个微服务的，这样每个微服务都能公平地加锁和释放锁。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术思考</tag>
      </tags>
  </entry>
  <entry>
    <title>git合并冲突的两种解决方案</title>
    <url>/posts/git%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>我们拉取了一个项目，在此分支进行，修改，同时别人也拉取了统一分支的代码进行修改而且也已经提交到远程，这时候如果我们将本地代码提交了并推送到远程，一定会出现代码冲突的问题，<br>如果我们在代码提交前，再git pull ,也会出现冲突问题, 那么有没有一个优雅的办法应对代码仓库冲突的问题，又避免内容丢失？</p>
</blockquote>
<p>有两种解决方案</p>
<p>1、git stash  -&gt;  git pull  -&gt; git stash pop -&gt; 解决冲突 -&gt;git add -&gt; git commit</p>
<p>2、git  commit  -&gt; git pull -&gt; 解决冲突 -&gt; git add -&gt;  git commit</p>
<p>对于第一种解决方案：</p>
<p>其中的git stash 会做这样的事：</p>
<p>1、将暂存区的代码和工作区的代码都保存下来</p>
<p>2、加 -u 参数，会把不被跟踪的文件（即它在工作区，但是永远不会被添加到暂存区）也保存下来  </p>
<p>所以git stash 会存储我们本地代码的操作记录，将本地的代码库恢复成本地最近一次拉取的状态，这样拉取远程代码就不会出现冲突问题，</p>
<p>当我们把我们的操作记录弹出，暂存区和工作区的代码会相应的恢复，我们就相当于在最新提交的版本上进行修改，但是同样会在工作区上出现冲突，我们手动解决冲突的文件，然后添加到暂存区，再提交我们的修改，就可以完美的推送到远程（前提还是远程的最新代码还是我们最近拉取的代码）</p>
<p>这种解决方案的好处是，当我们修改代码修改到一半时，想要同步和远程最新代码的内容，不想提交一个半成品，这样做就非常有用，就相当于我们代码的修改基于最新分支情况进行修改，提交记录就只有一次。</p>
<p>对于第二种解决方案：</p>
<p>首先git  commit会把我们当前修改的代码提交生成一个版本，这时候工作区和暂存区都很干净，</p>
<p>接着git pull，其实也分为两步，</p>
<p>先git fetch 将远程最新提交记录同步到本地，</p>
<p>然后git merge将本地最新一次的提交和远程最新一次的提交内容合并放到工作区，</p>
<p>若无冲突直接提交到暂存区并提交，</p>
<p>若有冲突会系统就会在工作区代码中注明哪些冲突，然后需要我们手动解决并手动添加到暂存区、再手动提交到版本库。</p>
<p>最后总结：</p>
<p>1、理解合并冲突并不容易，但也有方法，无论如何我们都要坚定的确信，冲突一定可以解决！冲突一定可以解决！冲突一定可以解决！</p>
<p>2、想要避免冲突，保护本地已经修改的代码，上述是最佳实践，</p>
<p>3、第一种推荐代码只完成了一半，但想和远程代码同步的，第二种推荐确认自己的修改无误时使用.</p>
<p>4、当本地提交的版本不是基于远程仓库的最新版本，一定会被拒绝push，</p>
<p>解决方案就是git push, 解决冲突，再提交</p>
<p>5、当本地正在修改代码，知道了远程已经迭代了代码需要同步时，如果直接git pull ,会覆盖掉工作区和暂存区的内容，也会被拒绝(因为在git merge 时会在工作区合并文件，并放到暂存区并提交，如果工作区不干净，即还有未add到暂存区的代码，就会覆盖其工作区中的代码，如果暂处区不干净，也会覆盖掉 ) ,（除非 在命令添加 –force，强制覆盖) </p>
<p>解决方案就是git stash ,git pull ,git stash pop ,然后解决冲突，再commit和push</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s是什么？</title>
    <url>/posts/k8s%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>网上对 k8s 含糊不清，以下是我对其的理解，分享给大家</p>
</blockquote>
<blockquote>
<p>背景介绍：假设公司有一个超大的 web 应用，其中有很多服务，比如 mysql、redis、日志收集服务、web 服务等等，每个服务都可以用一个容器单独运行起来。突然来了泼天的流量，这个应用火了！，大量的用户请求造成了极大的数据库读写压力，原来一个容器可以扛住，现在快扛不住了，有没有一种办法，可以根据请求量多少自动增加容器数量来应对这样的读写压力来避免这样的问题，然后用户量请求下来的时候又恢复到原来的梳理呢?嗯！这时 k8s 就闪亮登场！</p>
</blockquote>
<h2><span id="k8s-是什么">k8s 是什么？</span></h2><p>全程 Kubernetes，是一个开源的容器编排引擎，用来对容器化应用进行自动部署、扩缩和管理。</p>
<p>更大白话一点，它介于客户端和服务端之间，通过策略，协调和管理多个应用服务（容器），只需要一个 yaml 文件配置，定义应用的部署顺序等信息，就能自动部署应用到各个服务器上，还能让它们挂了自动重启，自动扩缩容。</p>
<h2><span id="k8s-怎么管理容器">k8s 怎么管理容器？</span></h2><p>那就不得不提 k8s 的内部实现，它包括两个部分，master 节点和 work 节点，每个节点可视为一个物理机，具体而言：</p>
<p><code>master 节点</code> 用于存储集群的所有数据、常规的 api 请求操作、后台任务调度、pod 的调度。<code>work 节点</code> 用于管理容器给容器提供工作环境。</p>
<p>再为具体一点：</p>
<p>Master 节点（控制台）用于管理容器：</p>
<ul>
<li>API Server：处理 REST 操作，提供集群的管理接口。</li>
<li>etcd：分布式键值存储，用于存储集群的所有数据。</li>
<li>Controller Manager：负责集群的常规后台任务。</li>
<li>Scheduler：负责将 Pod 调度到合适的节点上。</li>
</ul>
<p>Worker 节点用于运行容器：</p>
<ul>
<li>Kubelet：负责与 Master 节点通信，管理 Pod 的生命周期。</li>
<li>Kube-proxy：负责网络代理和负载均衡。</li>
<li>Container Runtime：如 Docker、containerd，负责运行容器。</li>
</ul>
<p><img src="https://uploader.shimo.im/f/7hh0JSYWYzHlhDLT.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3NTQwOTI4NDksImZpbGVHVUlEIjoibThBWk03QlFPRUlHMkxrYiIsImlhdCI6MTc1NDA5MjU0OSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwicGFhIjoiYWxsOmFsbDoiLCJ1c2VySWQiOjc1NDYzMzIxfQ.CueXxgPDmdJOpm6GPkK7oUMdbJp3hDjfBHIA_BV2-7M" alt="k8s的架构"></p>
<center>图片来源：小白 debug</center>
 

<h2><span id="k8s-怎么工作">k8s 怎么工作？</span></h2><p>以前我们的服务会上传到服务器，用户请求经过服务器上的 nginx 转发到我们服务暴露的接口上进行处理，</p>
<p>现在我们会将业务代码先打包成镜像，然后基于它创建容器并统一交给 k8s 进行管理，当用户请求来临，先通过 k8s 对请求进行转发，k8s 会在自己的master节点（控制台）查找到该请求应该访问的哪一个工作节点的哪一个 pod, 然后找到可以处理这个请求的容器，同时 k8s 会根据请求量大小，通过自身预设的规则和算法自动创建 pod 资源和销毁 pod 资源、迁移。</p>
<h2><span id="k8s-怎么使用">K8s 怎么使用？</span></h2><p>先写一个 yaml 文件，这个文件用来告诉 k8s 应该创建和管理哪容器，容器上的文件映射、端口映射、持久化位置、最多可以有多少个副本、可占有的资源等等，这个文件将通过 kubectl 命令行工具执行：<code>kubectl apply -f xx.yaml</code>，k8s 控制台会暴露接口让 kubectl 对齐操控。</p>
<p><img src="https://uploader.shimo.im/f/CX11lR9RMpzKmAgr.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3NTQwOTI4NDksImZpbGVHVUlEIjoibThBWk03QlFPRUlHMkxrYiIsImlhdCI6MTc1NDA5MjU0OSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwicGFhIjoiYWxsOmFsbDoiLCJ1c2VySWQiOjc1NDYzMzIxfQ.CueXxgPDmdJOpm6GPkK7oUMdbJp3hDjfBHIA_BV2-7M" alt="kubectl操控k8s示例"></p>
<center>图片来源：小白 debug</center>

<p>下面的概率会在撰写 yaml 文件时经常接触到，建议熟悉并背诵：</p>
<ul>
<li>namespace：虚拟集群，将 k8s 集群的资源分隔</li>
<li>node：工作节点，通常是一个物理服务器，pod 的载体，一个 pod 只能工作在一个 node</li>
<li>deployment：管理 Pod 副本的控制器，k8s 会在集群中保持制定数量的 Pod 副本</li>
<li>service：暴露应用的抽象对象，通过稳定的 IP 地址和 DNS 来访问 pod</li>
<li>pod：k8s 最小单位，可以有多个容器，共同组成一套服务</li>
</ul>
<h2><span id="k8s-的本质是什么">k8s 的本质是什么？</span></h2><p>用户请求到实际应用的中间层，简化服务的部署运维流程，它可以作为代理对请求进行转发，也可以分布式管理实际应用，使业务更加高可用更好管理，节省复杂的人工管理。</p>
<p><a href="https://golangguide.top/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/k8s%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88.html#cluster">参考链接</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>一文把反射说得明明白白</title>
    <url>/posts/%E4%B8%80%E6%96%87%E6%8A%8A%E5%8F%8D%E5%B0%84%E8%AF%B4%E5%BE%97%E6%98%8E%E6%98%8E%E7%99%BD%E7%99%BD/</url>
    <content><![CDATA[<blockquote>
<p>说到<strong>反射</strong>，大家可能并不陌生。Java有这个概念，Go语言也有。但无论是官网还是各路教程，往往说得玄乎又抽象，让人看完还是一脸问号。今天我们就用最通俗的语言，把它说清楚。</p>
</blockquote>
<p>先以 <strong>Java反射</strong> 举个例子。</p>
<h3><span id="1-先搞明白-java-运行时">1. 先搞明白 Java 运行时</span></h3><p>Java 写好的代码要先编译成 <code>.class</code> 字节码文件，再由 Java 虚拟机（JVM）翻译成二进制机器码运行。JVM 可以根据不同操作系统适配成对应的机器码，这就是 Java 那句经典口号——“一次编写，到处运行”。</p>
<p>所谓 <strong>运行时</strong>，就是 Java 代码编译成 <code>.class</code> 后，在 JVM 里运行的那个状态。</p>
<h3><span id="2-那反射跟运行时有什么关系">2. 那反射跟运行时有什么关系？</span></h3><p>反射的核心功能是：<strong>在运行时获取类的信息（方法名、字段、类型等），甚至调用它们，而不需要在代码里提前写死</strong>。</p>
<p>为什么能做到？<br>因为在编译 <code>.java</code> 文件成 <code>.class</code> 的时候，类的结构（方法名、参数类型、字段类型等）会被完整写进字节码文件里。JVM 不仅保存了这些信息，还提供了读取它们的 API。反射就是利用这些 API，在程序运行中获取到类型和值。</p>
<p>这就是反射的本质——<strong>运行时动态探测和操作类型信息</strong>。所以我们通过反射就不需要提前写死声明，他在运行时自己探测。</p>
<h3><span id="3-框架为什么爱用反射">3. 框架为什么爱用反射？</span></h3><p>知道了他的本质，我们再看它的应用场景，</p>
<p>举个 Java 框架的例子，比如 Spring Boot。<br>在我们自己写代码时，<code>new</code> 一个对象是显式写出来的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyService</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br></pre></td></tr></table></figure>

<p>而 Spring Boot 可以<strong>不用你手动写</strong>，就直接实例化一个对象并注入到类里。这背后就是反射——框架在运行时扫描类，通过反射找到可用的构造方法，然后动态 <code>new</code> 出对象。举个栗子：</p>
<p>假设你有如下的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// 标记为Spring管理的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Action performed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后你有一个需要MyService的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyService myService;  <span class="comment">// 自动注入MyService</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        myService.performAction();  <span class="comment">// 使用注入的MyService对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<p>@Component标记了MyService和Application类，Spring Boot会自动将它们注册为bean。</p>
<p>@Autowired标记在Application类的myService字段上，Spring会通过反射自动注入MyService的实例。</p>
<p>因此你并不需要显式地使用new MyService()来创建对象，Spring会在幕后通过反射来完成这一过程。</p>
<blockquote>
<p>其中@Component和@Autowired就是 Java 里的<strong>注解</strong>。 通常它写在类、方法、字段前面，形如 <code>@Something</code>，相当于一个标签，用来告诉框架“这里有特殊处理”。框架在启动时会扫描项目的所有类，通过反射获取它们的注解信息，然后按照注解规则去做事。</p>
</blockquote>
<blockquote>
<p>注解有两类： 1、标记类、方法、字段为bean，使得它们可以被Spring容器管理,如@Component ；2、注入其他bean到类的字段、方法或构造器中，帮助实现依赖注入，达到解耦目的，如@Autowired</p>
</blockquote>
<p>说白了，框架的本质就是一堆通用功能的集合。用盖房子打比方：</p>
<ul>
<li>以前我们写业务代码，得从零打地基、搬砖盖墙（搭建底层架构）</li>
<li>有了框架，就像开发商先帮你把毛坯房造好，你直接装修（写业务逻辑）就行</li>
</ul>
<p>而反射，就是框架实现“自动适配你写的代码”的关键工具。</p>
<h3><span id="4-go-语言里的反射">4. Go 语言里的反射</span></h3><p>Go 的反射原理和 Java 非常像：</p>
<table>
<thead>
<tr>
<th><strong>Java反射</strong></th>
<th><strong>Go反射</strong></th>
</tr>
</thead>
<tbody><tr>
<td>通过JVM的API访问类型的元信息（如<code>Class</code>、<code>Method</code>等）。</td>
<td>通过Go的<code>reflect</code>包来访问类型和值的元信息。</td>
</tr>
<tr>
<td>Java依赖JVM在运行时维护的类型信息。</td>
<td>Go依赖编译时生成的运行时类型信息。</td>
</tr>
<tr>
<td>主要通过<code>Class</code>类和<code>java.lang.reflect</code>包进行反射操作。</td>
<td>主要通过<code>reflect.Type</code>和<code>reflect.Value</code>进行反射操作。</td>
</tr>
</tbody></table>
<p>比如 Go 里的结构体标签（tag）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们用 <code>json.Marshal()</code> 把结构体转成 JSON 时，<code>encoding/json</code> 包会通过反射读取 <code>tag</code> 信息，然后决定用哪个字段名。</p>
<p>很多 Go 框架（如 Gin、GORM）也大量使用反射来实现自动映射、自动注入等功能。</p>
<h3><span id="5-总结">5. 总结</span></h3><p>反射其实没那么神秘——<strong>它就是在运行时，把“看似未知”的东西变成已知的，把“不可见”的类型和值变成可见并可操作的</strong>。它的实现依赖于语言编译器和运行时提供的元信息和接口。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Air 实现 Go 程序热启动</title>
    <url>/posts/%E4%BD%BF%E7%94%A8Air%E5%AE%9E%E7%8E%B0Go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<blockquote>
<p>热启动的意义在于，当你更改了代码，不用自己手动的编译，系统检查到代码的变化，自动重启，大大提高开发效率！下面是安装步骤，非常简单~</p>
</blockquote>
<p>1、安装 air</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/air-verse/air</span><br></pre></td></tr></table></figure>
<p>2、进入到项目的根目录，在终端执行下面的命令，得到.air.toml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">air init</span><br></pre></td></tr></table></figure>
<p>3、根据实际项目，调整.air.toml 中的内容，air 将按照下面规则热重启，建议理解每个参数的意思</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root = &quot;D:/project/your-project-name&quot;  # 项目根目录位置</span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">  pre_cmd = [&quot;source pre_env.sh&quot;,&quot;bee generate docs&quot;] # 在 go buid 前的命令，这里第一个是导入环境变量，第二个是更新 swagger 接口文档和路由</span><br><span class="line">  args_bin = []</span><br><span class="line">  bin = &quot;./tmp/main.exe&quot;  # 运行编译好的文件命令</span><br><span class="line">  cmd = &quot;go build -o ./tmp/main.exe your-project-name&quot; #构建项目命令</span><br><span class="line">  delay = 1000</span><br><span class="line">  exclude_dir = [&quot;tmp&quot;, &quot;vendor&quot;, &quot;testdata&quot; ,&quot;logs&quot; ,&quot;.idea&quot;,&quot;.git&quot;,&quot;docker&quot;] # 排除这些文件</span><br><span class="line">  exclude_file = []</span><br><span class="line">  exclude_regex = [&quot;_test.go&quot;]</span><br><span class="line">  exclude_unchanged = false</span><br><span class="line">  follow_symlink = false</span><br><span class="line">  full_bin = &quot;&quot;</span><br><span class="line">  include_dir = []</span><br><span class="line">  include_ext = [&quot;go&quot;, &quot;tpl&quot;, &quot;tmpl&quot;, &quot;html&quot; ,&quot;ini&quot; ,&quot;conf&quot;] # 这些文件一旦变化并保存就会触发重新构建并启动</span><br><span class="line">  include_file = []</span><br><span class="line">  kill_delay = &quot;1s&quot;</span><br><span class="line">  log = &quot;build-errors.log&quot;  #生成的日志名</span><br><span class="line">  poll = false</span><br><span class="line">  poll_interval = 0</span><br><span class="line">  post_cmd = []</span><br><span class="line">  pre_cmd = []</span><br><span class="line">  rerun = false</span><br><span class="line">  rerun_delay = 500</span><br><span class="line">  send_interrupt = false</span><br><span class="line">  stop_on_error = false</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4、在项目根目录下，终端执行 air，便可实现使用 Air 实现 Go 程序热启动</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">air</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.liwenzhou.com/posts/Go/live-reload-with-air/">参考</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>写接口的感悟</title>
    <url>/posts/%E5%86%99%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<blockquote>
<p>数据命名要规范，数据需要分析清楚再设计接口，对于写接口的时候先整体后局部，代码实现可以交给AI，在后端开发中，沟通是极为重要的，一定要花时间分析数据，下面分享一下自己写接口的经验流程：</p>
</blockquote>
<p>1、设计接口文档，先确定大致要实现的接口，每个接口的传参和入参、函数名，函数名要用驼峰命名，公有函数首字母大写，私有函数首字母小写。以及接口要实现的功能。</p>
<p>2、定义数据结构，根据提供数据和定义好的接口设计数据结构。</p>
<p>3、分层实现，从控制层开始写代码，不着急细节，用伪代码大致实现逻辑，然后实现方法，完善细节，自顶向下的做，现跑通再优化。</p>
<p>4、为了让代码更好读，每个函数的功能尽量满足单一职责原则，工具类函数单独用文件实现，重复代码需要封装，控制层的代码用来判断接口数据是否正确传入，包装返回值，验证身份等，服务层用来实现业务逻辑，模型层和数据库真正的打交道。</p>
<p>5、多用注释，先用注释要干什么，然后实现，最后用注释来解释为什么，代码本事解释干什么。</p>
<p>6、如果开发无法专注就是休息不够，不要吝啬休息的重要性。</p>
<p>7、沟通的占据开发过程中的80%，所以不要着急写代码，经可能花多的时间理解需求，做好需求分析，与业务方沟通，善用工具减少沟通成本，比如使用swagger实现接口文档，遇到问题直接面对面交流效率更直接。</p>
<p>8、面对复杂的功能，要问题拆解，列出123，功能就会浮出水面。</p>
<p>9、每天的工作一定要记录，方便复盘。</p>
<p>10、没有被用到的代码直接删。</p>
<p>11、时刻想到资源释放：如数据库连接、文件流是否及时关闭，避免内存泄漏。</p>
<p>12、“测试驱动开发（TDD）” 思路 —— 先定义接口的测试用例，再写实现代码，而非 “写完再凑测试”。（这一步需要好好学习！）</p>
<p>13、接口的耗时控制：是否在服务层存在不必要的循环 &#x2F; 计算，是否需要异步处理非核心流程。</p>
<p>总之，个人感觉接口开发不仅是 “写代码实现功能”，而应该是是 “设计一个稳定、安全、易维护的服务契约”，重在还是多练习多思考。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>别再死记硬背！用问题驱动，深入浅出理解微服务核心概念</title>
    <url>/posts/%E5%88%AB%E5%86%8D%E6%AD%BB%E8%AE%B0%E7%A1%AC%E8%83%8C%EF%BC%81%E7%94%A8%E9%97%AE%E9%A2%98%E9%A9%B1%E5%8A%A8%EF%BC%8C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<blockquote>
<p>微服务框架中，一直会接触ProtoBuf的概念，微服务在搭建的过程中，使用上，需要编写.proto 后缀命名的文件，我们定义了数据的结构和接口，然后我们就使用这个文件生成对应的代码，当客户端调用远程方法的时候，会依赖于这个文件调用服务端提供的方法，服务端实现的方法会依赖于这个文件进行注册，所以这到底是什么？为什么他能够这么做，接下来我们通过问题的驱动下，一起来揭秘它神秘的面纱~</p>
</blockquote>
<p>ProtoBuf(协议缓冲区)，wiki上解释，是一种免费的开源跨平台数据格式，用于序列化结构化数据。<strong>该方法涉及一种描述某些数据结构的接口描述语言，以及一个根据该描述生成源代码的程序，用于生成或解析表示结构化数据的字节流</strong>。它在开发通过网络相互通信或存储数据的程序时非常有用。</p>
<p>本质上他也是一种语言，可以理解为不同编译语言的中间语言，它类似于json，每个语言都认识，我们可以通过 ProtoBuf 定义数据结构，并生成多种语言（如 Java, Go, Python, C++ 等）相应的代码，这样<strong>不同语言的微服务之间就能通过统一的数据格式来交换数据</strong>。</p>
<h3><span id="1protobuf-是谁提出和实现的它的实现最开始是为了解决什么问题">1.ProtoBuf 是谁提出和实现的？它的实现最开始是为了解决什么问题？</span></h3><p>由 Google 提出，最初是为了处理 Google 内部大量数据通信和存储时的性能问题。 它的目标是提供一个高效、跨平台的序列化工具，能减少带宽消耗并提高通信效率。 </p>
<p><strong>关键点</strong>：</p>
<ul>
<li><p><strong>解决性能瓶颈</strong>：为大规模数据存储和高效网络传输提供支持。 </p>
</li>
<li><p><strong>跨平台兼容</strong>：可以支持多种语言和平台。</p>
</li>
</ul>
<hr>
<h3><span id="2-protobuf-的作用与意义它在微服务中扮演什么角色">2. ProtoBuf 的作用与意义，它在微服务中扮演什么角色？</span></h3><p><strong>作用是定义数据结构并对其进行序列化</strong>。 在 <strong>微服务</strong> 中，ProtoBuf 通过提供一种标准化的格式（接口定义），使得不<strong>同语言实现的服务可以进行跨语言通信</strong>。不同语言的服务通过ProtoBuf 提供的统一的接口和消息格式进行通信，避免了传统的 JSON 或 XML 传输中的效率瓶颈。 </p>
<p><strong>关键点</strong>：</p>
<ul>
<li><p><strong>统一接口</strong>：定义接口、请求体参数和返回值。 </p>
</li>
<li><p><strong>跨语言通信</strong>：不同语言可以互相通信。 </p>
</li>
<li><p><strong>数据格式统一</strong>：避免了 JSON 或 XML 的性能损耗。</p>
</li>
</ul>
<hr>
<h3><span id="3-同样是跨平台数据格式为什么不用-json-而是protobuf">3. 同样是跨平台数据格式，为什么不用 JSON 而是ProtoBuf？</span></h3><p><strong>ProtoBuf</strong> 比 JSON 更高效：它使用<strong>二进制格式</strong>进行数据序列化，传输速度更快、占用带宽更小。 <strong>性能对比</strong>：JSON 是文本格式，解析和序列化更慢，而 ProtoBuf 的二进制格式更紧凑、解析速度更快。 <strong>跨语言支持</strong>：ProtoBuf 更容易通过生成对应语言的代码来实现跨语言通信，而 JSON 没有那么强的类型和协议支持。 </p>
<p><strong>关键点</strong>：</p>
<ul>
<li><p><strong>性能更好</strong>：二进制格式比 JSON 更高效。 </p>
</li>
<li><p><strong>跨语言支持</strong>：ProtoBuf 通过生成代码支持多种语言。</p>
</li>
</ul>
<hr>
<h3><span id="4-rpc-协议与-http-协议的区别它们都是应用层协议吗">4. RPC 协议与 HTTP 协议的区别，它们都是应用层协议吗？</span></h3><p>RPC 通常用于微服务间的高效通信，而 HTTP 更多用于 Web 服务中的请求-响应通信。 </p>
<p><strong>关键点</strong>：</p>
<ul>
<li><p><strong>RPC</strong> 更适合服务间通信，支持远程调用。 </p>
</li>
<li><p><strong>HTTP</strong> 适合客户端和服务器之间的请求响应。</p>
</li>
</ul>
<hr>
<h3><span id="5grpc中服务端的服务注册在哪客户端调用的方法是直接在-grpc-上吗还是注册中心直接和服务器交互吗">5.gRPC中，服务端的服务注册在哪，客户端调用的方法是直接在 gRPC 上吗，还是注册中心？直接和服务器交互吗？</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务端启动 → 注册地址到注册中心 → 注册中心维护服务列表  </span><br><span class="line">客户端启动 → 从注册中心获取服务地址 → 生成存根 → 存根通过gRPC协议直接调用服务端</span><br></pre></td></tr></table></figure>
<p> 服务注册：<strong>gRPC 本身不自带服务注册功能</strong>，在微服务场景中，需结合 Consul、Etcd 等第三方注册中心实现。gRPC 服务器启动时，会通过自定义代码或第三方 SDK 将自身地址、服务名称等信息注册到注册中心，由注册中心维护服务实例的动态列表（包括新增、下线、健康状态等）。<br>客户端调用：客户端调用分为两个阶段。首先是服务发现，客户端启动时或定期向注册中心请求目标服务的可用实例地址；然后，客户端根据 gRPC 协议文件生成本地存根（Stub），通过存根调用远程方法，存根会按照 gRPC 协议（基于 HTTP&#x2F;2）将请求参数序列化后，直接与获取到地址的 gRPC 服务器建立连接并发送请求，服务端处理后将结果返回给客户端。</p>
<p><strong>关键点：</strong></p>
<p><strong>服务注册</strong>：依赖第三方注册中心管理服务实例，非 gRPC 内置功能。</p>
<p><strong>客户端与服务器交互</strong>：客户端先从注册中心获取服务地址，再通过存根与服务器直接交互，注册中心不参与通信过程。</p>
<hr>
<h3><span id="6grpc-存根是什么和grpc-服务器端的关系存根是框架自动生成的吗">6.gRPC 存根是什么，和gRPC 服务器端的关系，存根是框架自动生成的吗？</span></h3><p>gRPC 存根与服务器端通过 .proto 文件关联，<strong>存根</strong>由框架根据 .proto 自动生成，分客户端和服务端。客户端存根封装通信细节，服务端存根负责解析请求、调度业务实现。<strong>服务器端</strong>基于服务端存根实现具体业务逻辑，处理客户端通过存根发起的调用。</p>
<p><strong>关键点</strong>：</p>
<p><strong>存根</strong>：自动生成，是通信桥梁，隐藏网络细节。</p>
<p><strong>服务器端</strong>：实现业务逻辑，通过存根接收和处理请求。</p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法-go语言实现</title>
    <url>/posts/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>最常用的排序算法：快速排序 和 归并排序。<br>适用于数值范围较小或均匀分布：计数排序 和 桶排序。<br>适合小规模数据或者部分有序的数据：冒泡排序、选择排序 和 插入排序。</p>
</blockquote>
<blockquote>
<p>以下示例以从小到大排序为例</p>
</blockquote>
<h2><span id="1-冒泡排序">1、冒泡排序</span></h2><p>和相邻的数比较，比它大交换，向左移动，直到列表的末尾，返回，重复过程</p>
<p>时间复杂度：o(n^2)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nums)-i<span class="number">-1</span>;j++&#123;</span><br><span class="line">      <span class="keyword">if</span> nums[j]&gt;nums[j+<span class="number">1</span>]&#123;</span><br><span class="line">        nums[j],nums[j+<span class="number">1</span>]=nums[j+<span class="number">1</span>],nums[j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-选择排序">2、选择排序</span></h2><p>在未排序数组中选择一个最小的放到已经排序数组的最后面，重复过程</p>
<p>时间复杂度：o(n^2)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choseSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">    min:=i</span><br><span class="line">    <span class="keyword">for</span> j:=i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums);j++&#123;</span><br><span class="line">      <span class="keyword">if</span> nums[j]&lt;nums[min]&#123;</span><br><span class="line">          min=j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i],nums[min]=nums[min],nums[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="3-插入排序">3、插入排序</span></h2><p>将未排序数组的第一个数和已经排序的数组元素依次比较，插入到合适的位置</p>
<p>时间复杂度：o(n^2)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">    cur:= nums[i]</span><br><span class="line">    j := i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; current &#123;</span><br><span class="line">        nums[j+<span class="number">1</span>]=nums[j]</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j+<span class="number">1</span>] = cur</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="4-快速排序">4、快速排序</span></h2><p>选择一个基数，大的放右边，小的放左边，然后分别对左边和右边重复这样的操作</p>
<p>时间复杂度：o(nlog(n))</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">  &#125;</span><br><span class="line">  base:=nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br><span class="line">  l,r:=<span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> l&lt;=r&#123;</span><br><span class="line">    <span class="keyword">for</span> l&lt;=r&amp;&amp;nums[l]&lt;base&#123;</span><br><span class="line">      l++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l&lt;=r&amp;&amp;nums[r]&gt;base&#123;</span><br><span class="line">      r--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l&lt;=r&#123;</span><br><span class="line">        nums[l],nums[r]=nums[r],nums[l]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(nums[:r+<span class="number">1</span>])</span><br><span class="line">  quickSort(nums[l:])</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-归并排序">5、归并排序</span></h2><p>将未排序数组划分两组，得到的两组继续递归操作，切半划分，直到划分的组不能被划分，合并两个数组，返回再合并</p>
<p>时间复杂度：o(nlog(n))</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  size:=<span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="keyword">if</span> size&lt;=<span class="number">1</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">  &#125;</span><br><span class="line">  left:=mergeSort(nums[:size/<span class="number">2</span>])</span><br><span class="line">  right:=mergeSort(nums[size/<span class="number">2</span>:])</span><br><span class="line">  <span class="keyword">return</span> merge(left,right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(str1 []<span class="type">int</span>,str2 []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  res:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>，<span class="built_in">len</span>(str1)+<span class="built_in">len</span>(str2))</span><br><span class="line">  i,j:=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i&lt;<span class="built_in">len</span>(str1)&amp;&amp;j&lt;<span class="built_in">len</span>(str2)&#123;</span><br><span class="line">    <span class="keyword">if</span> str1[i]&lt;str2[j]&#123;</span><br><span class="line">      res=<span class="built_in">append</span>(res,str1[i])</span><br><span class="line">      i++</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res=<span class="built_in">append</span>(res,str2[j])</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i&lt;<span class="built_in">len</span>(str1)&#123;</span><br><span class="line">    res=<span class="built_in">append</span>(res,str1[i])</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">for</span> j&lt;<span class="built_in">len</span>(str2)&#123;</span><br><span class="line">    res=<span class="built_in">append</span>(res,str2[j])</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="6-堆排序">6、堆排序</span></h2><p>将未排序数组构建一个完全二叉树，找到倒数第一个非叶子节点（n&#x2F;2-1),与子节点比较，交换比自己大的子节点， 构建一个大根堆，每次取第一个，直到取完（大根堆可以让空间复杂度降为 o(1))</p>
<p>时间复杂度：o(nlog(n))</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">  &#125;</span><br><span class="line">  buidHeap(nums)</span><br><span class="line">  res:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(nums)&gt;<span class="number">0</span>&#123;</span><br><span class="line">    val,newNums:=pop(nums)</span><br><span class="line">    res=<span class="built_in">append</span>(res,val)</span><br><span class="line">    nums=newNums</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(nums []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   i:=<span class="built_in">len</span>(nums)/<span class="number">2</span><span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> i&gt;=<span class="number">0</span>&#123;</span><br><span class="line">      adjustHeap(nums,i,<span class="built_in">len</span>(nums))</span><br><span class="line">      i--</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjustHeap</span><span class="params">(nums []<span class="type">int</span>,i <span class="type">int</span>,size <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  maxIndex:=i</span><br><span class="line">  left,right:=i*<span class="number">2</span>,i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> left&lt;size &amp;&amp;nums[maxIndex]&lt;nums[left]&#123;</span><br><span class="line">     maxIndex=left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> i*<span class="number">2</span>+<span class="number">1</span>&lt;size&amp;&amp;nums[maxIndex]&lt;nums[right]&#123;</span><br><span class="line">     maxIndex=right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> maxIndex!=i&#123;</span><br><span class="line">    nums[i],nums[maxIndex]=nums[maxIndex],nums[i]</span><br><span class="line">    adjustHeap(nums,maxIndex,size)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(nums []<span class="type">int</span>)</span></span>(<span class="type">int</span>,[]<span class="type">int</span>) &#123;</span><br><span class="line">    top:=nums[<span class="number">0</span>]</span><br><span class="line">    nums[<span class="number">0</span>]=nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">    newNums:=nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">    adjustHeap(nums,<span class="number">0</span>,<span class="built_in">len</span>(newNums))</span><br><span class="line">    <span class="keyword">return</span> top,newNums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="7-希尔排序">7、希尔排序</span></h2><p>改进版的插入排序，跳着排，最后会间隔为 1 排</p>
<p>时间复杂度：o(n^(3&#x2F;2))</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> nums</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> gap:=<span class="built_in">len</span>(nums)/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>&#123;</span><br><span class="line">     <span class="keyword">for</span> i:=gap;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">         cur:=nums[i]</span><br><span class="line">         j:=i</span><br><span class="line">         <span class="keyword">for</span> j&gt;=gap&amp;&amp;nums[j-gap]&gt;cur&#123;</span><br><span class="line">           nums[j]=nums[j-gap]</span><br><span class="line">           j-=gap </span><br><span class="line">         &#125;</span><br><span class="line">         nums[j]=cur</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="8-桶排序">8、桶排序</span></h2><p>分桶→桶内排序→合并，每个桶都有范围限制，将数据分到对应的桶中，对每个桶中的数据分别排序，然后合并每个桶的数据</p>
<p>时间复杂度：o(n*k)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> nums</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 找到数组中最大和最小的</span></span><br><span class="line">   minNum,maxNum:=nums[<span class="number">0</span>],nums[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">     <span class="keyword">if</span> nums[i]&lt;minNum&#123;</span><br><span class="line">       minNum=nums[i]</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> nums[i]&gt;maxNum&#123;</span><br><span class="line">       maxNum=nums[i] </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   bucketNum:=<span class="built_in">len</span>(nums)</span><br><span class="line">   bucketSize:=(maxNum-minNum)/bucketNum</span><br><span class="line">   buckets:=<span class="built_in">make</span>([][]<span class="type">int</span>,bucketNum)</span><br><span class="line">   <span class="comment">//将数据放到桶中</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">     index:=(nums[i]-minNum)/bucketSize</span><br><span class="line">     <span class="keyword">if</span> index==bucketNum&#123;</span><br><span class="line">       index=bucketNum<span class="number">-1</span></span><br><span class="line">     &#125;</span><br><span class="line">     buckets[index]=<span class="built_in">append</span>(buckets[index],nums[i])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//排序每个桶并合并</span></span><br><span class="line">   res:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;bucketNum;i++&#123;</span><br><span class="line">     sort.Ints(bucket[i])</span><br><span class="line">     res=<span class="built_in">append</span>(res,bucket[i]...)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="9-基数排序">9、基数排序</span></h2><p>跟桶排序很像，先根据个位的数字排序，然后根据十位，依次递推，直到该数组最大数的最高位</p>
<p>时间复杂度：O(n*k)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> nums</span><br><span class="line">  &#125;</span><br><span class="line">  maxNum:=nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">    <span class="keyword">if</span> nums[i]&gt;maxNum &#123;</span><br><span class="line">       maxNum=nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  maxDigit := <span class="type">int</span>(math.log10(<span class="type">float64</span>(maxNum))) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;maxDigit;i++&#123;</span><br><span class="line">    bucket:=<span class="built_in">make</span>([][]<span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nums);j++&#123;</span><br><span class="line">       <span class="comment">// 获取指定位的数字</span></span><br><span class="line">       digit := (nums[j] / <span class="type">int</span>(math.Pow10(i))) % <span class="number">10</span></span><br><span class="line">       bucket[digit]=<span class="built_in">append</span>(bucket[digit],nums[j])</span><br><span class="line">    &#125;</span><br><span class="line">    nums=<span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++&#123;</span><br><span class="line">      nums=<span class="built_in">append</span>(nums,bucket[j]...)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="10-计数排序">10、计数排序</span></h2><p>统计待排数组中每个元素的个数，然后对其进行合并</p>
<p>时间复杂度：O(n + k)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(nums []<span class="type">int</span>)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到数组中最大和最小的</span></span><br><span class="line">  minNum,maxNum:=nums[<span class="number">0</span>],nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">    <span class="keyword">if</span> nums[i]&lt;minNum&#123;</span><br><span class="line">      minNum=nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[i]&gt;maxNum&#123;</span><br><span class="line">      maxNum=nums[i] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  counts:=<span class="built_in">make</span>([]<span class="type">int</span>,maxNum-minNum+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">    counts[nums[i]-minNum]++</span><br><span class="line">  &#125;</span><br><span class="line">  res:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(counts);i++&#123;</span><br><span class="line">    <span class="keyword">for</span> count[i]&gt;<span class="number">0</span>&#123;</span><br><span class="line">      res=<span class="built_in">append</span>(res,i+minNum)</span><br><span class="line">      count[i]-- </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>博客诞生记</title>
    <url>/posts/%E5%8D%9A%E5%AE%A2%E8%AF%9E%E7%94%9F%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本指南是我搭建这个网站的全过程，让<a href="https://manus.im/share/gEmD0mNtTVLkImBCX4EfVV?replay=1">Manus</a>给我生成的搭建指南，现在把指南全部保留分享给大家，指南很详细，亲测有效，总之，不要畏惧，AI时代，想法落地So Easy！相信自己！Enjoy it ～</p>
</blockquote>
<hr>
<h2><span id="环境准备">环境准备</span></h2><p>开始搭建个人博客之前，需要在Windows系统上安装必要的软件环境。本指南将详细介绍每个步骤，确保您能够顺利完成博客的搭建。</p>
<h3><span id="系统要求">系统要求</span></h3><ul>
<li>Windows 10 或更高版本</li>
<li>至少 4GB RAM</li>
<li>2GB 可用磁盘空间</li>
<li>稳定的网络连接</li>
</ul>
<h3><span id="所需软件">所需软件</span></h3><ol>
<li><strong>Node.js</strong> - JavaScript运行环境</li>
<li><strong>Git</strong> - 版本控制工具</li>
<li><strong>代码编辑器</strong> - 推荐 VS Code 或 Notepad++</li>
</ol>
<hr>
<h2><span id="nodejs安装">Node.js安装</span></h2><p>Node.js 是运行 Hexo 的基础环境，我们需要先安装它。</p>
<h3><span id="步骤1下载nodejs">步骤1：下载Node.js</span></h3><ol>
<li>访问 Node.js 官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></li>
<li>点击 “LTS” 版本下载（推荐使用长期支持版本）</li>
<li>选择 Windows Installer (.msi) 64位版本</li>
</ol>
<h3><span id="步骤2安装nodejs">步骤2：安装Node.js</span></h3><ol>
<li>双击下载的 <code>.msi</code> 文件启动安装程序</li>
<li>点击 “Next” 继续</li>
<li>接受许可协议，点击 “Next”</li>
<li>选择安装路径（建议使用默认路径）</li>
<li>在功能选择页面，确保勾选以下选项：<ul>
<li>Node.js runtime</li>
<li>npm package manager</li>
<li>Add to PATH（重要：这将自动配置环境变量）</li>
</ul>
</li>
<li>点击 “Next” 然后 “Install”</li>
<li>等待安装完成，点击 “Finish”</li>
</ol>
<h3><span id="步骤3验证安装">步骤3：验证安装</span></h3><ol>
<li>按 <code>Win + R</code> 打开运行对话框</li>
<li>输入 <code>cmd</code> 并按回车打开命令提示符</li>
<li>输入以下命令验证安装：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure>

<p>如果显示版本号，说明安装成功。</p>
<h3><span id="配置npm镜像可选但推荐">配置npm镜像（可选但推荐）</span></h3><p>为了提高包下载速度，建议配置国内镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>验证配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="git安装">Git安装</span></h2><p>Git 是版本控制工具，用于管理代码和部署博客到 GitHub Pages。</p>
<h3><span id="步骤1下载git">步骤1：下载Git</span></h3><ol>
<li>访问 Git 官方网站：<a href="https://git-scm.com/">https://git-scm.com/</a></li>
<li>点击 “Download for Windows”</li>
<li>下载最新版本的 Git</li>
</ol>
<h3><span id="步骤2安装git">步骤2：安装Git</span></h3><ol>
<li>双击下载的 <code>.exe</code> 文件启动安装程序</li>
<li>点击 “Next” 继续</li>
<li>选择安装路径（建议使用默认路径）</li>
<li>在组件选择页面，建议勾选：<ul>
<li>Git Bash Here（右键菜单集成）</li>
<li>Git GUI Here</li>
<li>Git LFS (Large File Support)</li>
</ul>
</li>
<li>选择默认编辑器（推荐 VS Code 或 Notepad++）</li>
<li>选择初始分支名称：选择 “Override the default branch name for new repositories” 并输入 “main”</li>
<li>调整PATH环境：选择 “Git from the command line and also from 3rd-party software”</li>
<li>选择HTTPS传输后端：使用 “Use the OpenSSL library”</li>
<li>配置行尾转换：选择 “Checkout Windows-style, commit Unix-style line endings”</li>
<li>配置终端模拟器：选择 “Use MinTTY”</li>
<li>其他选项保持默认，点击 “Install”</li>
</ol>
<h3><span id="步骤3验证安装">步骤3：验证安装</span></h3><p>打开命令提示符，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>如果显示版本号，说明安装成功。</p>
<h3><span id="步骤4配置git用户信息">步骤4：配置Git用户信息</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些信息将用于提交记录。</p>
<hr>
<h2><span id="hexo安装与配置">Hexo安装与配置</span></h2><p>现在我们开始安装和配置 Hexo 博客框架。</p>
<h3><span id="步骤1安装hexo-cli">步骤1：安装Hexo CLI</span></h3><p>打开命令提示符（以管理员身份运行），输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>等待安装完成。</p>
<h3><span id="步骤2验证hexo安装">步骤2：验证Hexo安装</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>

<p>如果显示版本信息，说明安装成功。</p>
<hr>
<h2><span id="创建博客项目">创建博客项目</span></h2><h3><span id="步骤1选择博客目录">步骤1：选择博客目录</span></h3><ol>
<li>在您希望存放博客的位置创建一个文件夹，例如 <code>D:\MyBlog</code></li>
<li>在该目录下打开命令提示符：<ul>
<li>在文件夹空白处按住 <code>Shift</code> 键，右键点击</li>
<li>选择 “在此处打开命令窗口” 或 “在此处打开PowerShell窗口”</li>
</ul>
</li>
</ol>
<h3><span id="步骤2初始化hexo项目">步骤2：初始化Hexo项目</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 <code>my-blog</code> 的文件夹，包含完整的博客项目结构。</p>
<h3><span id="步骤3项目结构说明">步骤3：项目结构说明</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-blog/</span><br><span class="line">├── _config.yml          # 站点配置文件</span><br><span class="line">├── package.json         # 应用程序信息</span><br><span class="line">├── scaffolds/           # 模板文件夹</span><br><span class="line">├── source/              # 资源文件夹</span><br><span class="line">│   ├── _drafts/         # 草稿文件夹</span><br><span class="line">│   └── _posts/          # 文章文件夹</span><br><span class="line">├── themes/              # 主题文件夹</span><br><span class="line">└── node_modules/        # 依赖包文件夹</span><br></pre></td></tr></table></figure>

<h3><span id="步骤4启动本地服务器">步骤4：启动本地服务器</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>或简写为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>打开浏览器访问 <code>http://localhost:4000</code>，您应该能看到默认的博客页面。</p>
<hr>
<h2><span id="博客配置与定制">博客配置与定制</span></h2><h3><span id="基本配置">基本配置</span></h3><p>编辑根目录下的 <code>_config.yml</code> 文件，配置您的博客信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网站信息</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的个人博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;分享技术与生活&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;这是一个基于Hexo搭建的个人博客，记录技术学习和生活感悟&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">技术,博客,生活,学习</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">您的名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL配置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://yourusername.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3><span id="创建新文章">创建新文章</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新页面</span></span><br><span class="line">hexo new page <span class="string">&quot;页面名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>文章将在 <code>source/_posts/</code> 目录下生成，使用 Markdown 格式编写。</p>
<h3><span id="文章格式示例">文章格式示例</span></h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2025-01-27 10:00:00</span><br><span class="line">tags: [标签1, 标签2]</span><br><span class="line"><span class="section">categories: [分类名称]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">这里是文章内容，使用Markdown语法编写。</span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 列表项1</span><br><span class="line"><span class="bullet">-</span> 列表项2</span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文字**</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*斜体文字*</span></span><br><span class="line"></span><br><span class="line">[<span class="string">链接文字</span>](<span class="link">https://example.com</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">图片描述</span>](<span class="link">图片路径</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="主题安装">主题安装</span></h3><p>Hexo 有丰富的主题生态，推荐几个优秀主题：</p>
<h4><span id="1-next主题简洁优雅">1. NexT主题（简洁优雅）</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next next</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<h4><span id="2-butterfly主题功能丰富">2. Butterfly主题（功能丰富）</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>

<h4><span id="3-fluid主题现代化设计">3. Fluid主题（现代化设计）</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-fluid</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">fluid</span></span><br></pre></td></tr></table></figure>

<h3><span id="常用插件">常用插件</span></h3><p>安装一些有用的插件来增强博客功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成站点地图</span></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成RSS订阅</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索功能</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="github-pages部署">GitHub Pages部署</span></h2><p>GitHub Pages 是免费的静态网站托管服务，非常适合托管 Hexo 博客。</p>
<h3><span id="步骤1创建github账户">步骤1：创建GitHub账户</span></h3><ol>
<li>访问 <a href="https://github.com/">https://github.com/</a></li>
<li>点击 “Sign up” 注册账户</li>
<li>验证邮箱地址</li>
</ol>
<h3><span id="步骤2创建仓库">步骤2：创建仓库</span></h3><ol>
<li>登录GitHub后，点击右上角的 “+” 号</li>
<li>选择 “New repository”</li>
<li>仓库名称必须是：<code>你的用户名.github.io</code><ul>
<li>例如：如果用户名是 <code>zhangsan</code>，仓库名就是 <code>zhangsan.github.io</code></li>
</ul>
</li>
<li>设置为 Public（公开）</li>
<li>勾选 “Add a README file”</li>
<li>点击 “Create repository”</li>
</ol>
<h3><span id="步骤3配置ssh密钥推荐">步骤3：配置SSH密钥（推荐）</span></h3><p>为了安全地推送代码，建议配置SSH密钥：</p>
<ol>
<li>打开Git Bash</li>
<li>生成SSH密钥：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>按回车使用默认路径，可以设置密码或直接回车</li>
<li>复制公钥内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在GitHub上添加SSH密钥：<ul>
<li>点击头像 → Settings</li>
<li>左侧菜单选择 “SSH and GPG keys”</li>
<li>点击 “New SSH key”</li>
<li>粘贴公钥内容，点击 “Add SSH key”</li>
</ul>
</li>
</ol>
<h3><span id="步骤4配置hexo部署">步骤4：配置Hexo部署</span></h3><p>编辑博客根目录下的 <code>_config.yml</code> 文件，在文件末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署配置</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:你的用户名/你的用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>如果没有配置SSH，也可以使用HTTPS：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/你的用户名/你的用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<h3><span id="步骤5安装部署插件">步骤5：安装部署插件</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3><span id="步骤6部署博客">步骤6：部署博客</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到GitHub</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>或者使用简写命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h3><span id="步骤7访问博客">步骤7：访问博客</span></h3><p>部署成功后，访问 <code>https://你的用户名.github.io</code> 即可看到您的博客。</p>
<hr>
<h2><span id="常见问题解决">常见问题解决</span></h2><h3><span id="问题1npm安装速度慢">问题1：npm安装速度慢</span></h3><p><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用淘宝镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h3><span id="问题2hexo命令不识别">问题2：hexo命令不识别</span></h3><p><strong>可能原因：</strong></p>
<ul>
<li>Node.js未正确安装</li>
<li>环境变量未配置</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li>重新安装Node.js，确保勾选”Add to PATH”</li>
<li>手动添加环境变量：<ul>
<li>右键”此电脑” → 属性 → 高级系统设置</li>
<li>环境变量 → 系统变量 → Path</li>
<li>添加Node.js安装路径（通常是 <code>C:\Program Files\nodejs\</code>）</li>
</ul>
</li>
</ol>
<h3><span id="问题3端口4000被占用">问题3：端口4000被占用</span></h3><p><strong>错误信息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: listen EADDRINUSE :::4000</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用其他端口</span></span><br><span class="line">hexo server -p 5000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者找到占用进程并结束</span></span><br><span class="line">netstat -ano | findstr :4000</span><br><span class="line">taskkill /PID 进程ID /F</span><br></pre></td></tr></table></figure>

<h3><span id="问题4部署时权限错误">问题4：部署时权限错误</span></h3><p><strong>解决方案：</strong></p>
<ol>
<li>确保SSH密钥配置正确</li>
<li>检查仓库权限设置</li>
<li>使用HTTPS方式部署</li>
</ol>
<h3><span id="问题5中文文件名乱码">问题5：中文文件名乱码</span></h3><p><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置Git编码</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line">git config --global i18n.commit.encoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br></pre></td></tr></table></figure>

<h3><span id="问题6主题安装后样式异常">问题6：主题安装后样式异常</span></h3><p><strong>解决方案：</strong></p>
<ol>
<li>清理缓存：<code>hexo clean</code></li>
<li>重新生成：<code>hexo generate</code></li>
<li>检查主题配置文件</li>
<li>确保主题版本与Hexo版本兼容</li>
</ol>
<h3><span id="问题7图片无法显示">问题7：图片无法显示</span></h3><p><strong>解决方案：</strong></p>
<ol>
<li>将图片放在 <code>source/images/</code> 目录下</li>
<li>在文章中使用相对路径：<code>![描述](/images/图片名.jpg)</code></li>
<li>或者安装图片处理插件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></li>
</ol>
<h3><span id="问题8github-pages访问慢">问题8：GitHub Pages访问慢</span></h3><p><strong>解决方案：</strong></p>
<ol>
<li>使用CDN加速</li>
<li>考虑使用国内的Gitee Pages</li>
<li>优化图片大小和数量</li>
</ol>
<hr>
<h2><span id="进阶配置">进阶配置</span></h2><h3><span id="自定义域名">自定义域名</span></h3><p>如果您有自己的域名，可以配置自定义域名：</p>
<ol>
<li>在 <code>source/</code> 目录下创建 <code>CNAME</code> 文件</li>
<li>在文件中写入您的域名（不带http:&#x2F;&#x2F;）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.yourdomain.com</span><br></pre></td></tr></table></figure></li>
<li>在域名提供商处配置DNS记录：<ul>
<li>添加CNAME记录，指向 <code>你的用户名.github.io</code></li>
</ul>
</li>
</ol>
<h3><span id="博客备份">博客备份</span></h3><p>为了防止数据丢失，建议定期备份：</p>
<ol>
<li>创建备份仓库</li>
<li>将整个博客项目推送到备份仓库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;博客备份&quot;</span></span><br><span class="line">git remote add origin https://github.com/你的用户名/blog-backup.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3><span id="评论系统">评论系统</span></h3><p>添加评论功能：</p>
<h4><span id="使用gitalk">使用Gitalk</span></h4><ol>
<li><p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gitalk --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在GitHub创建OAuth App：</p>
<ul>
<li>Settings → Developer settings → OAuth Apps</li>
<li>记录Client ID和Client Secret</li>
</ul>
</li>
<li><p>在主题配置中启用Gitalk</p>
</li>
</ol>
<h4><span id="使用valine">使用Valine</span></h4><ol>
<li>注册LeanCloud账户</li>
<li>创建应用，获取App ID和App Key</li>
<li>在主题配置中启用Valine</li>
</ol>
<h3><span id="seo优化">SEO优化</span></h3><p>提高搜索引擎排名：</p>
<ol>
<li><p>安装SEO插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提交站点地图到搜索引擎</p>
</li>
</ol>
<h3><span id="统计分析">统计分析</span></h3><p>添加访问统计：</p>
<ol>
<li><p><strong>Google Analytics</strong></p>
<ul>
<li>注册Google Analytics账户</li>
<li>获取跟踪ID</li>
<li>在主题配置中添加</li>
</ul>
</li>
<li><p><strong>百度统计</strong></p>
<ul>
<li>注册百度统计账户</li>
<li>获取统计代码</li>
<li>在主题配置中添加</li>
</ul>
</li>
</ol>
<h3><span id="性能优化">性能优化</span></h3><p>提升博客加载速度：</p>
<ol>
<li><p><strong>图片优化</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-imagemin --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码压缩</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CDN加速</strong></p>
<ul>
<li>使用jsDelivr加速静态资源</li>
<li>配置图片CDN</li>
</ul>
</li>
</ol>
<h3><span id="自动化工作流">自动化工作流</span></h3><p>使用GitHub Actions自动部署：</p>
<ol>
<li>在博客仓库创建 <code>.github/workflows/deploy.yml</code>：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">source</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;16&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="总结">总结</span></h2><p>恭喜您！通过本指南，您已经学会了：</p>
<ol>
<li>✅ 在Windows系统上安装必要的开发环境</li>
<li>✅ 使用Hexo创建个人博客</li>
<li>✅ 配置和定制博客外观</li>
<li>✅ 部署博客到GitHub Pages</li>
<li>✅ 解决常见问题</li>
<li>✅ 进行进阶配置和优化</li>
</ol>
<h2><span id></span></h2><h3><span id="有用的资源">有用的资源</span></h3><ul>
<li><strong>Hexo官方文档</strong>：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li>
<li><strong>主题市场</strong>：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li>
<li><strong>插件市场</strong>：<a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a></li>
<li><strong>Hexo社区</strong>：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></li>
</ul>
<hr>
<p><em>本指南最后更新于：2025年7月29日</em></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>在AI时代，程序员该怎么学习，哪些核心技能AI没法代替？</title>
    <url>/posts/%E5%9C%A8AI%E6%97%B6%E4%BB%A3%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%8A%80%E8%83%BDAI%E6%B2%A1%E6%B3%95%E4%BB%A3%E6%9B%BF%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>先说说自己的思考</p>
</blockquote>
<h3><span id="0-说在前面">0、说在前面</span></h3><p>1、 <code>系统学习计算机基础</code> 、底层设计、设计思想，学习技术实现思想比会一门技术更重要！</p>
<p>2、沟通能力，团队协作能力， <code>与人打交道的能力</code> ,学会说清楚问题的能力</p>
<p>3、aI是工具，它不能创造，但是人类有，最重要是发现问题、提出问题，那么一定要 <code>锻炼好自己提示词撰写</code> 的能力。</p>
<p>4、发挥 <code>个人想象力</code> ，从自身的欲望出发，去寻找“有什么是之前的痛点但是没有办法实现的呢？，然后用 AI 解决它。解决的过程，自然就学会了必备知识和技能。</p>
<p>5、学会 <code>利用ai更快解决自己的问题</code> ，比如后端开发工作中，想想哪些最浪费时间，怎么用ai的方式来解决它（用好ai自动测试&#x2F;文档生成）。</p>
<hr>
<blockquote>
<p>AI的回答，感觉也很有道理，但很模糊，选择性看吧！</p>
</blockquote>
<h3><span id="1-程序员的学习方向">1、程序员的学习方向</span></h3><p>个人总结：学习架构设计、掌握ai工具、问题驱动学习、眼光不只局限于技术</p>
<p><strong>与AI深度协作</strong></p>
<ol>
<li><p>让AI处理80%的常规代码，专注解决20%的架构设计、复杂系统集成等核心问题。</p>
</li>
<li><p>掌握主流AI工具（如GitHub Copilot、AI代码审查工具等），提升开发效率。</p>
</li>
</ol>
<p><strong>聚焦技术本质</strong></p>
<ol>
<li><p>系统性学习编程语言底层原理（如内存管理、并发机制）。</p>
</li>
<li><p>以问题驱动学习：结合实际业务场景，深挖技术原理而非机械式啃书。</p>
</li>
</ol>
<p><strong>拓展跨界能力</strong></p>
<ol>
<li><p>培养技术判断力：识别何时使用&#x2F;不使用AI，避免技术滥用。</p>
</li>
<li><p>增强商业敏感度：理解技术如何转化为商业价值，关注行业需求变化。</p>
</li>
</ol>
<hr>
<h3><span id="2-ai难以替代的核心技能">2、AI难以替代的核心技能</span></h3><p>个人总结：系统设计（需要各种开发经验）、创新性思考、沟通能力、价值判断（需要哲学人文思考）</p>
<p><strong>系统架构设计能力</strong></p>
<ol>
<li><p>复杂系统的抽象建模、模块拆分与集成设计。</p>
</li>
<li><p>平衡性能、可维护性、扩展性等非功能性需求。</p>
</li>
</ol>
<p><strong>问题抽象与创新思维</strong></p>
<ol>
<li><p>将模糊需求转化为技术方案，设计AI工具无法预见的解决路径。</p>
</li>
<li><p>突破常规逻辑的创新性思考（如算法优化、新技术应用场景探索）。</p>
</li>
</ol>
<p><strong>技术判断与决策能力</strong></p>
<ol>
<li><p>评估技术选型的合理性（如分布式架构 vs 单体架构）。</p>
</li>
<li><p>风险预判与容灾设计（如分布式系统的一致性保障）。</p>
</li>
</ol>
<p><strong>跨领域协作能力</strong></p>
<ol>
<li><p>与非技术人员沟通需求（如产品经理、业务方）。</p>
</li>
<li><p>协调多团队资源推进复杂项目落地。</p>
</li>
</ol>
<p><strong>价值判断与伦理思考</strong></p>
<ol>
<li><p>技术方案的道德边界把控（如隐私保护、算法公平性）。</p>
</li>
<li><p>业务场景的合理性评估（避免”技术滥用”）。</p>
</li>
</ol>
<hr>
<h3><span id="3-学习建议">3、学习建议</span></h3><p><strong>时间分配</strong></p>
<ol>
<li><p>每周20%时间探索前沿技术（如AI工程化、新型编程范式）。</p>
</li>
<li><p>通过实践项目验证技术方案（例如性能优化、系统重构）。</p>
</li>
</ol>
<p><strong>能力验证指标</strong></p>
<ol>
<li><p>能否独立设计可扩展的复杂系统架构。</p>
</li>
<li><p>是否具备将业务需求转化为技术架构的”翻译能力”。</p>
</li>
<li><p>是否可以快速描述需求，抓住本质，说清楚问题。（个人补充）</p>
</li>
</ol>
<hr>
<p>最后我想说，AI的加持，我们想要学习知识变得触手可及，它的出现让敢想到敢做的门槛变得非常低，但是很多人却缺乏这样的勇气，事实上也包括我自己，个人感觉花点时间想想自己想要什么非常重要，而不是人云亦云，多看点书多与人交流，开阔视野，也能够更好洞察事情的本质，减少无效努力的发生。专注于自己的生活。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术思考</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员应该知道的38件事儿</title>
    <url>/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8438%E4%BB%B6%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h2><span id="1-简化根本复杂性消除偶发复杂性">1. 简化根本复杂性，消除偶发复杂性</span></h2><p>根本复杂性指的是问题与生俱来的、无法避免的困难。比如，协调全国的空中交通，必须实时追踪每架飞机的位置、高度、航速、航向、目的地、降落次序等，才能避免空中和地面冲突。以及还要兼顾因天气原因等航班延误导致的变化。</p>
<p>与之相反，偶发复杂性是解决根本复杂性过程中衍生的，即解决方案本身带来了新问题。比如笨拙的语言语法会导致大家轻易犯错、忘记释放内存导致 <code>OOM</code> 等；比如因为系统设计不佳导致需要更多的对账脚本或监控系统等。</p>
<p>软件开发是为了解决一套高度错综复杂、环环相扣的概念的全部细节问题。之所以存在根本复杂性，就是因为要和复杂、无序的现实世界对接；要准确、完整的识别依赖关系和例外情况；要设计出<strong>完全正确</strong>而不是大致正确的解决方案。这是完全无法避免的根本复杂度。</p>
<p><strong>管理复杂性是软件开发最重要的课题</strong>，可以通过划分子模块、拆解子系统甚至到类的定义、子函数的拆分都是为了将复杂度拆解为简单的部分，隐藏细节，暴露简单的接口。各模块&#x2F;类之间不要跟一团毛线一样混乱。这样才能易于理解，方便扩展。不要逼迫大脑去理解高复杂度的东西，而应该逐步拆解、简化复杂度，方便大脑理解。</p>
<p>我们应该合理划分职责，进而能够编写<strong>高扇入、低扇出</strong>的类。（高扇入表示被很多类依赖，低扇出表示不依赖太多其他类；和高内聚&#x2F;低耦合是一回事儿）</p>
<p>关注根本复杂性，消除偶发复杂性，抽丝剥茧制定解决方案，才是真正的挑战。</p>
<blockquote>
<p>《软件设计的哲学》中对复杂度有更多的讨论</p>
</blockquote>
<h2><span id="2-对待技术债务要谨慎">2. 对待技术债务要谨慎</span></h2><p>在一次迭代开始时，各项需求看上去安排的张弛有度，但仍无法避免在某个时间承受巨大的进度压力，当你发现必须在 <strong>干得快</strong> 和 <strong>干得好</strong> 之间选择时候，一般都会选择 <strong>干得快</strong>，并提醒自己将来再回头来返工优化。但实际上下一轮迭代总会有下一个问题，将来永不会来。这类久拖不决的任务就是 <strong>技术债</strong> ，<strong>技术债</strong> 就像贷款，短期能获得好处，但你总要付出利息。时间久了，利息也将是一笔难以偿还的债务。因为有债务的存在，新功能的加入将变得困难，而且这些债务也将是 <code>bug</code> 的滋生地。</p>
<p>我们很容易说服自己，当前变更引入的一点点<strong>技术债</strong>并不算什么大问题。就跟破窗效应一样，只要放开了口子，系统会腐化的很快。变坏容易，变好很难。</p>
<p>尽量避免拖欠技术债务，应该要采取<strong>零容忍</strong>策略。如果迫不得已，也要在任务卡片上追踪这笔债务，及时偿还，不要遗忘。</p>
<h2><span id="3-分析需求背后的意义">3. 分析需求背后的意义</span></h2><p>假如用户提出一个需求：设计一架飞行速度在 2.5 马赫(2.5 倍音速)的低成本战斗机。</p>
<p>因为风阻和速度的平方成正比，从 1 马赫到 2 马赫，需要的动力和机身设计有更严苛的要求。但通过追问为什么需要这种类型的战机时，得到的答案是：<strong>为了快速撤离战场</strong>，因为用户想利用速度优势撤离战场。</p>
<p>了解需求之后，可以有更好的方案：通过提升推力重量比，改善战机的加速性能和机动变向性能，用灵巧性取代了对速度的需求。</p>
<p>我们首次遇到的用户需求可能只是用户&#x2F;产品从自己角度想到的一个方案，可能并不是最佳的。可以通过分析用户需求的真正意义，定位真正的问题，尝试提出比用户的建议更好、成本更低的方案。而了解真正需求的办法也很简单：面对用户，不断问为什么。如果用户(也可能是产品)并不能回答你的问题，那么你可以想一下是否需要 <code>Say NO</code>。</p>
<h2><span id="4-美在于简单">4. 美在于简单</span></h2><p>有些东西是我们在代码中尽力争取的，比如：</p>
<ul>
<li><p>可读性</p>
</li>
<li><p>可维护性、扩展性</p>
</li>
<li><p>开发速度</p>
</li>
<li><p>“难以捉摸”的美的追求</p>
</li>
</ul>
<p>对 <strong>美</strong> 我们都有自己的判断，但 <strong>简单</strong> 一定是它的内在品质。一个应用或者系统无论多么复杂，其中每个单独的组成部分都保持着它的简洁性：简单的模块承担了单一的职责，它包含着同样简单的方法，而且方法的功能如同其名称描述的一样，简单且直接。</p>
<p>不仅每一个组成部分本身的职责要简单，而且与系统其它部分也应该保持着简单的关系。美来自于简单，亦存在于简单。有时因为问题本身很复杂，实现自然也会是复杂的，那就把这些复杂性封装到模块内部，使得模块之间的交互是简单的。</p>
<blockquote>
<p>比如文件系统是复杂的，但是作为封装的模块，对外暴露的只有 <code>open</code> <code>read</code> <code>write</code> <code>lseek</code> <code>close</code> 几个方法。所以这是一个好的设计。如果非要选择，模块拥有一个简单的接口比拥有一个简单的实现更重要。<br>对问题最好的解决方案，就是能够满足该问题的所有需求且最为简单的解决方案。如何衡量简单呢？</p>
</blockquote>
<p>1）是否能快速读懂。</p>
<p>2）是否易于创建，不只是代码敲出来，而是 <code>debug</code> 并写对的时间，复杂的代码通常需要好一阵才能写对。</p>
<p>3）代码的数量。</p>
<p>4）新概念的数量。</p>
<p>简单不是简化，不要把问题想简单了。比如“爬楼梯”算法，递归确实简单，但是当台阶级数比较多时，递归耗时太久，并不是一个好的方案。</p>
<p>更进一步，有时需要简化的是问题而不是方案，当问题难以解决的时候，回头看看这个问题是否合理。比如上面提到的 2.5 马赫的战机。还比如你还没学会使用动态规划或者其他算法解决“爬楼梯”，再回到这个问题来看，现实中台阶数会不会很大呢？并不会，十几级台阶而已，如果计算过程不是在关键路径上，递归看起来又不是不可接受。问题本身是不是个有效问题，远比采用什么方案更重要。</p>
<p><strong>控制复杂度</strong>，是所有编程原则的总则。编程工作的核心就是与复杂度较量。添加功能会让代码复杂，代码复杂，使用起来就困难，项目进展就会变慢。要写好代码，就要尽量拖延代码变复杂的时机，如果非这么做不可的时候再写。即使要写也要尽量消除重复，设法调整架构，使得新添加的功能不会令系统的整体复杂度大幅上升，这才是编程中最难的部分。</p>
<blockquote>
<p>思从深而行从简</p>
</blockquote>
<h2><span id="5-少即是多">5. 少即是多</span></h2><p><code>Less is More</code>，虽然是一句老掉牙的格言，但也确实是至理名言。</p>
<p>不要过度实现，不要预计将来会用到，不要觉得这里性能可能会有问题而提早优化，不要做现在不需要但你觉得将来需要的工作。<strong>你编写的代码，只应该解决目前确实存在的这些问题，而不是去解决你正在设想的问题，因为你永远不知道接下来会遇到什么问题。</strong></p>
<p>系统设计应该保留可扩展性，扩展性更多的是在<strong>接口扩展性设计</strong>&#x2F;<strong>外部依赖的可扩展性</strong>等设计层面，这些一般都不需要太早的代码实现。比如接口层面保留引入本地缓存的能力，但先不要写本地缓存的实现代码，因为会增加数据一致性的复杂度和代码复杂度，等以后需要了再添加即可。</p>
<p><strong>最好的代码是不能再删减一行的代码，哪怕是注释。</strong></p>
<h2><span id="6-时刻想着删减代码">6. 时刻想着删减代码</span></h2><p>删除一行代码带给我的成就感要多于增加一行代码。<strong>代码是负债，而不是资产</strong>，对于增加代码我们要吝啬，用新增代码量来衡量工作是愚蠢的。新增的代码都需要维护，而且代码都可能会出错，通过删减代码来提升代码质量也是一种尝试，能用 8 行代码实现的就不要用 10 行。</p>
<p>我们在局部或服务整体重构之后，老代码没有下掉，意味着运维责任多了一倍，这都是负债，我们并没有比重构前变得更轻松。 当然并不是只有重构才能下线代码，冗余的逻辑、无效的代码、不再使用的接口功能等等都是可以删减的代码；实在不济，去掉一些无效或错误的注释也是一份功劳。</p>
<p>运行不到的代码是不管用的，称为死代码。如果发现某段代码已经没人用了，而且可以安全的删掉，这应该是个值得高兴的事情，应该比你新写代码更值得高兴，因为你在不影响功能下缩减了代码量，减少了维护成本。</p>
<p>当然，删减代码并不会被纳入 <code>OKR</code>目标中，但正如运动能够减脂增肌一样，这就是对程序员而言<strong>难而正确的事</strong>。</p>
<h2><span id="7-故障终究会发生">7. 故障终究会发生</span></h2><p>机械硬盘的平均无故障工作时间是 3 年，也就是说有 1000 多块硬盘的机房每天都会有故障发生。硬件会出错，于是增加冗余资源提升系统可靠性，虽然可以避免单点故障导致的错误，但更多的硬件会有更大的概率故障。</p>
<p>软件也会出错，于是增加额外的监控程序，但监控程序也是软件，一样会出错。</p>
<p>人无完人，我们也会犯错，因此我们把操作和处理都变成自动化。自动化虽然降低了主动犯错的概率，却增加了错误被忽略的概率。何况任何自动化应对变化的能力远不及人类，于是又为自动化增加监控，结果是更多的软件，更多的故障率。</p>
<p>所以我们不得不承认：系统中必然存在不同形式的故障隐患，无论如何都无法彻底消灭。只有承认这一点，我们才能对特定的故障设计对策，就比如汽车工程师知道交通事故无法避免，所以设计了 安全带、气囊、撞击缓冲区等来保护乘客。因此你的系统也应该设计预防措施来限制故障，可能是限流、熔断、降级、异常上报，甚至是数据恢复脚本。</p>
<p>不应该惧怕故障，也不应该像鸵鸟把头插进沙子里一样对故障视而不见。</p>
<h2><span id="8-不要忽略那个错误">8. 不要忽略那个错误</span></h2><blockquote>
<ol>
<li>一条错误日志</li>
<li>用户反馈的一个不符合预期的 Case</li>
<li>代码中对错误的处理</li>
<li>数据库中的数据不符合预期<br>如果你选择忽略类似上面的一个错误，对其视而不见，假装一切都没发生，那你就是在背负巨大的风险。不顾红灯亮起，继续前行，结果只会招致更大的损失，要在时机初现的时候就动手，把损失减少到最小。</li>
</ol>
</blockquote>
<p>编译器的警告不要忽略，<code>codecc</code>的警告不要忽略，对每个调用后的错误检查不要省略。错误才是常态，不要忽略任何错误，因为一切都正常实在是小概率事件。</p>
<h2><span id="9-问题要追踪到根本原因">9. 问题要追踪到根本原因</span></h2><ul>
<li><p>不是稳定复现的，重试没问题就忽略了</p>
</li>
<li><p>看板数据有一些异常波动，查起来麻烦，反馈一下得了</p>
</li>
<li><p>不是我服务的问题，客户端或者外部系统的问题，先不管了</p>
</li>
<li><p><code>QA</code>反馈了个 <code>bug</code>，在代码里加了个 <code>if</code>判断处理了一下就给放过了</p>
</li>
</ul>
<p>等等很多只解决了问题表面，而没有根本解决问题。多问“为什么”？直到查明真正的原因。计算机不会撒谎，也不会骗你，所有不符合你预期的行为都值得追查一下，要不就是程序或数据哪里错了，要不就是你的预期错了。不管修正哪一个错误，都是有意义的。</p>
<p>比如最近在业务上，用户反馈购买会员后视频试看结束仍然出蒙层无法播放，分析发现是客户端从后端没有获取到购买成功的信息而拦截，但客户端并没有请求发出和响应的日志。一切都很诡异，如果选择让用户重装一下也是能恢复的。但如果继续追查原因，会发现是客户端对登录态判断逻辑有问题，导致没有发请求。所以用户不能看的根本原因是登录态判断有问题。但凡中间断了没有追查到底，都不能揪出根因。</p>
<p>如果过往经历中没有抓耳挠腮、茶饭不思的追查过几个问题，是有点不完整的。只有在追查根本原因的过程中，才能学到东西并且印象深刻。</p>
<h2><span id="10-营地法则要让离开时的营地比进入时干净">10. 营地法则：要让离开时的营地比进入时干净</span></h2><blockquote>
<p>努力留下一个比你发现时更好的世界 - Robert<br>当你发现地上有脏东西，不管是谁造成的，都要把它清理干净。提交代码时同样如此，只需要 <code>commit</code> 提交时好于 <code>checkout</code> 时即可，你可能仅仅改进了一些变量命名的可读性，或者把长函数拆分成两个短函数；你可以是打破了一个循环依赖，或者增加了一个接口解耦策略和实现细节。</p>
</blockquote>
<p>做的事情可大可小，但是要变好。</p>
<blockquote>
<p>具体可实施的小步改进可参照《重构》</p>
</blockquote>
<h2><span id="11-多问自己用户会怎么做">11. 多问自己：用户会怎么做？</span></h2><p>外网用户没有程序员的意识和能力来解决问题，也不会认可程序员使用的界面模式和提示信息；因此你在界面底部的一次错误提示，用户可能根本就看不见；同时，用户也不会按下 <code>F12</code>看一下接口调用是否正常。</p>
<p>要想知道用户的真实想法，最好就是观察一个用户的完整操作。给他一个 <code>APP</code>，看他完整的操作轨迹。你要一直问自己：为什么他要那样做？为什么他不那样做？</p>
<p>不要用用户访谈代替观察用户，因为他们访谈的表述和操作之间会有巨大差异。用户在使用你的应用时，在你看来就是个“傻子”。直接观察用户是获取需求的最佳途径，用户到底想要什么？与其闷头猜测，不如花一小时去仔细观察。</p>
<p>敬畏外网用户的反馈，一条外网反馈意味着 1000 个用户遇到了问题。不要无视他们，他们使用并乐于反馈问题，我们要珍惜并积极响应。每一次用户反馈问题的解决，都是提升用户满意度的最有效举措。</p>
<p>如果你在滴滴就去当一名司机体验几天，看一下接送流程是否有优化空间。如果在美团就当一名骑手，加入线下骑手团，问一下骑手们接送单过程是否有问题。如果你不是一名游戏玩家，你就不知道这个游戏做的到底怎么样。</p>
<blockquote>
<p>当然，也不可能所有人都去当司机或者抓人过来搞测试，但是总有其他办法：</p>
<p><em>比如滴滴建设了“听音工具”，让一线研发可以去听客服解决用户进线的录音，知道用户会有哪些问题，客服是如何解决的。</em><br>有千万用户的应用都会建设一个好的埋点系统，好好分析用户点击轨迹行为。这样的边际成本为 0，而且还很客观。</p>
</blockquote>
<h2><span id="12-设计两次">12. 设计两次</span></h2><p>软件设计不是一件简单的事情，所以你对如何构建模块的第一个想法不太会是一个好的设计。多做一个备选方案，对比它们，一定会对你有所启发。尝试选择那些彼此截然不同的方法，这样你会学到更多。当然，最重要还是要考虑上层软件的易用性。</p>
<p>对比多个方案，挑选最佳方案，或者整合推动产生最佳方案。多否定自己，多从使用者角度考虑是否合理。设计两次并不会浪费太多时间，设计上浪费的两个小时，相比实现需要的两周而言，不值一提。今天设计好之后，先放在那，切换一下头脑，等待灵光一现看是否有更合理的方案。</p>
<p>但我们大家都是聪明人，我们会觉得没有必要<strong>设计两次</strong>，因为第一次的设计就是<strong>天才的杰作</strong>。但软件设计是一件很难的事情，没有人第一次就做对，所以：尝试设计两次。</p>
<h2><span id="13-对代码审查好一点">13. 对代码审查好一点</span></h2><p>你可能不喜欢代码审查 <code>Code Review</code>，就跟不喜欢让别人看到你内裤的颜色一样。但我们应该知道，代码审查不仅仅是更正代码错误，其目的还是<strong>共享知识</strong>、建立统一的代码指导标准。代码审查的时候态度要温和，确保评语是有建设性的，不是刻薄的。同样，对评审意见的回复也不应该是“设计如此”&#x2F;“这次先这样”等无意义的回复。</p>
<p>应该月度组织一场“代码审查会议”，在会议上畅谈“代码为什么这样写”和“怎么写可以更好”，可以针对一个命名、一个范式、一个循环判断、单测是否有效、数据库设计是否合理、领域模型是否正确、代码分层和模块划分是否合适等等问题充分讨论。如果这个过程中有<strong>点心</strong>和<strong>饮料</strong>，那代码审查的过程会充满乐趣，并且值得期待。</p>
<h2><span id="14-良好的命名就是最佳的文档">14. 良好的命名就是最佳的文档</span></h2><p>编程无非就是在对 26 个字母排列组合，如何能让别人读懂你的代码，除去更大范围的模式设计之外，在一个屏幕可见范围内，良好的变量和函数命名是最有助于让读者看懂你代码的实现。</p>
<ul>
<li><p>不要写注释：如果必须添加注释才能说明一段代码的含义，那就拆分成多个子函数，用函数名来表述注释要表达的含义。</p>
</li>
<li><p>不要为了少打几个字母而缩减名称。<code>x</code> <code>y</code> <code>xr</code> <code>rn</code> 等，除非它的作用域只有两三行。</p>
</li>
<li><p>不要将多种命名习惯混用，要保持一致，比如昵称不要混用 <code>nick</code> 和 <code>name</code>，在全场景使用一个就好; 另外，符合惯用法，比如 <code>empty()</code> 方法，一般场景用于判断 <strong>是否为空</strong>，那么就不要给这个方法再赋予<strong>清空该容器</strong>的动词含义。</p>
</li>
<li><p>词要达意，存储名称的集合，不要叫 <code>nameList</code>，直接 <code>names</code>就好。尽量不要使用 <code>itemData</code>, <code>userInfo</code> 等含义很广，必需要深入看实现才能懂的命名。</p>
</li>
<li><p>名称的长短和名称的作用域成正比。短循环内局部变量就用短命名。整个函数声明周期的命名就要长一些。</p>
</li>
</ul>
<p>命名最重要的就是精确性和一致性。不要过于笼统或者模糊。对重复使用的概念，保持一致的命名。不要一会儿 <code>title</code> 一会儿 <code>name</code></p>
<blockquote>
<p>对变量的命名要像给自己孩子起名一样慎重，好的名字十分重要，但往往并非唾手可得。</p>
</blockquote>
<h2><span id="15-要写注释">15. 要写注释</span></h2><p><strong>注释的目的是补充代码所不能表达的意图。如果能通过调整代码结构、重命名函数和变量就能解释清楚的就不要写注释。代码应该能向下一个接替我的程序员解释自己</strong>，注释并非总是邪恶的，它们和代码结构一样重要。在代码顶部写上注释，用来说明代码要完成什么事情；在代码内部加上注释，可以让其他开发人员知晓如何修复或扩展这些代码。对复杂项目来说，通过阅读代码来了解其行为是不现实的, 注释是快速了解项目的入口。</p>
<p>设身处地的为以后的读者或者 15 分钟前的自己想一想：你希望知道什么？</p>
<p>注释主要将代码中不明显的东西揭示给读者：</p>
<ul>
<li><p>不要写行内注释，使用有意义的命名来代替行内注释。</p>
</li>
<li><p>不要为显而易见的代码添加注释</p>
</li>
<li><p>不要注释旧代码，直接删掉它</p>
</li>
<li><p>不要写<strong>在做什么</strong>，而要写<strong>为什么</strong>。比如这个注释就能解决读者疑惑：由于需要尽可能减少网络请求的次数，代码处理变得复杂了。</p>
</li>
</ul>
<p>审阅代码时，如果你发现一段逻辑理解起来很吃力，而代码本身也没有太多优化空间，请不要迟疑，勇敢表达出你对于<strong>注释</strong>的需求吧！</p>
<h2><span id="16-早部署常部署">16. 早部署，常部署</span></h2><p>软件开发中，部署和调试我们往往会被放在项目的最后去做，前面的步骤我们都在假定一切都是正常的。协议会按照约定实现，正在做的功能就是用户想要的，只需要等待最后时刻全部拿出来，一定能惊艳众人。</p>
<p>但是真到了交付的时候会发现问题很多：协议和预期的不一致、产品说这个功能不是 Ta 想要的。这个时候不是陷入需求撕扯中，要不就是加班加点的修改。何其痛苦。这时候不如把开发过程切开一下，完成一些功能之后我们就部署联调一次，这会确保我们已经完成的工作是有效而且可控的。</p>
<p>早部署、早交付、常部署、常交付，越早部署就越能发现问题，不要堆到最后一把梭哈。</p>
<h2><span id="17-不要怕搞砸">17. 不要怕搞砸</span></h2><p>你可能有过这样的经历：</p>
<ul>
<li><p>基础代码相当不稳定；系统结构差，更改一样东西总会破坏另一个不相关的功能；</p>
</li>
<li><p>无论增加什么功能，编码人员的目标都是尽可能少的改动，每次到了发布时间，都提心吊胆；</p>
</li>
<li><p>耦合严重，很难找到修改切入点。每次的修改都会影响到老功能；</p>
</li>
</ul>
<p>任何作出系统更改的理由都如此痛苦。因为系统病了，它需要一个医生。你知道系统出了问题，但是你会担心你的优化修改是否会引入新的问题，你会秉持 <strong>能用就行</strong> 的原则得过且过。这个时候请大胆一些，不要怕搞砸，就像手术一样，为了治疗疾病总是需要几道切口。切口会愈合，系统也是这样。花在重构&#x2F;优化上的时间能够在项目生命周期里得到数倍的回报。</p>
<p>重构过程中，你需要重新定义内部接口、重新设计模块，以及采用减少依赖的方式简化代码。通过这些工作，可以显著降低代码的复杂度。</p>
<p>同时保持 <strong>测试完备</strong>，重构的前提是你有测试用例证明你的重构是安全的，不管是回归测试还是 <code>diff</code>测试，这些重构的改动都应该在可控范围内。</p>
<p>不要犹豫，如果你觉得系统需要优化，不管大小，请勇敢前行。</p>
<h2><span id="18-决定重构之前先想想这能不能比原来好一倍">18. 决定重构之前，先想想这能不能比原来好一倍</span></h2><blockquote>
<p>上一条我们鼓励优化重构，是的，这一条却希望你慎重，这很矛盾<br>简单来看，程序员分为两类：</p>
</blockquote>
<ul>
<li><p>喜欢<strong>渐进的思考</strong>，总是基于现有方案来思考每一个问题，通过调整现有方案来解决新的问题</p>
</li>
<li><p>总喜欢用一个系统解决所有问题，而不只是当前这个问题，因此，只要有机会，他们就想<strong>从头设计</strong>方案</p>
</li>
</ul>
<p>这两种倾向走向极端，都会造成灾难。如果所有修复都是小修小补，那你会将自己困住，无法从更大维度思考问题，他们的说辞总是“不可能”、“时间不够”等。反之，如果所有方案都需要从头开始，仅凭一个单独的用例，就决定重做整个系统那你会将前一套架构带给你的知识丢掉，陷入<strong>原地转圈&#x2F;不断重构</strong>的过程，这类同学只从解决方案出发，来论证需要重构，而没有能够从当前需要解决的问题出发。凡事不从问题出发的提议，都是值得怀疑的。</p>
<p>如何决定选择<strong>小的优化修复</strong>还是<strong>重构</strong>呢？ 那就是：<strong>重构&#x2F;优化之后能不能比原来好一倍</strong></p>
<ul>
<li><p>研发效能是不是高一倍？</p>
</li>
<li><p>系统性能是否高一倍？</p>
</li>
<li><p>问题反馈环比下降是否能好一倍？</p>
</li>
<li><p>之前因架构不能支持的功能，是否可以支持到？（从这个角度看，不只是好一倍，从零到一是好了无数倍）</p>
</li>
</ul>
<p>好一倍是对<strong>必须有大幅改变才值得大幅变更</strong>的粗略量化描述，不要因为好一点就换掉现有东西，只有在强很多的情况下才值得去做。</p>
<p>当我们不知道要还是不要的时候，应该果断的选择不要，至少是暂时不要，直到我们清楚的知道为什么要。</p>
<h2><span id="19-不要重复你自己">19. 不要重复你自己</span></h2><p>很经典的 <strong>“DRY”原则</strong> ，它可能是所有编程原则里最根本的原则之一。</p>
<p><strong>重复就是浪费</strong>，每一行代码都会被维护到，而且可能是未来 <code>buy</code> 的潜在来源，重复的代码会带来代码库的膨胀，增加了复杂度，维护成本也会增加。<code>DRY</code>的要求是在一个系统内，每一块知识必须有一个单一的、明确的、权威的表示。</p>
<p><strong>将重复的过程调用自动化</strong>， 人工测试很慢，所以需要自动化测试。代码集成部署手工完成耗时且容易出错，所以有了流水线。但凡需要重复多次的工作，都需要自动化。如果经常需要处理相同格式的文本，就写一个包含 <code>cut</code> <code>grep</code> <code>sed</code> <code>awk</code> 的脚本帮你完成工作。</p>
<blockquote>
<p>重复不仅仅指代码的重复，即使代码不同但实现了同样的功能，或者不同代码在描述同一个领域模型概念，都是重复。</p>
</blockquote>
<h2><span id="20-没有高手神话请把问题描述清楚">20. 没有高手神话，请把问题描述清楚</span></h2><p>如果有人问你这样一个问题：</p>
<blockquote>
<ol>
<li>我碰到一个 <code>XYZ</code>异常，你知道问题出在哪里吗？</li>
<li>创作者不能发文了，帮忙看一下吧？</li>
<li>群里发你一个没有上下文的截图，或者群里@你，帮忙看一下？<br>上面的问题反馈还是一个完整的句子，有的同学在提问问题的时候都没有断句和标点，甚至有错别字和倒装句。遇到这种情况真的是苦不堪言。</li>
</ol>
</blockquote>
<p>你一定会满头问号，心里怒骂：没有堆栈信息、没有错误日志、没有信息上下文、没有 <code>trace</code>链路信息，没有对比截图，仅凭一句话就寻求你的帮助，希望你能看懂并且帮助解决问题。对方真是把你当成神仙高手了。</p>
<p>提出问题的人可能更适合回答问题，因为他有更多的信息上下文。<strong>所以在对别人提出问题的时候，请把问题使用对方能理解的词汇和方式描述清楚，并且把上下文也要描述清楚</strong></p>
<blockquote>
<p>总之一句话：会问问题。</p>
</blockquote>
<h2><span id="21-学习新语言">21. 学习新语言</span></h2><p>我们假设一种场景：</p>
<ol>
<li><p>业务同学讲了十分钟，提出一个需求，期望能对产品做一个改进，进而吸引更多的用户使用</p>
</li>
<li><p>业务人员在讲的过程中，技术同学在草纸上画起了神秘的符号</p>
</li>
<li><p>业务同学讲完之后，一脸期待的看着技术同学</p>
</li>
<li><p>技术同学低声讨论完之后，走到白板旁，一边画着表示多个系统视图的复杂图形，一边以复杂的技术术语解释为何没有对系统做出重大升级之前无法支持这个需求</p>
</li>
<li><p>业务人员很震惊，如此简单的需求竟然需要如此巨大的改变</p>
</li>
<li><p>技术同学也很诧异，业务同学竟然没理解他刚绘制的架构改动才能适配需求</p>
</li>
</ol>
<p>问题就在这里，没有一方能够理解另一方的意思，也不理解对方言论中的一些词语。相比和自己不同的人，和与自己类似的人相处会更舒服，这是基本的心理学规律。</p>
<blockquote>
<p>新语言并不特指明编程语言，更多的是不同的领域概念。<br>想象一下，如果技术同学能够以业务同学可理解的术语向其解释其中的问题，业务同学以技术能够理解的术语解释业务上的问题，上述情况将会有改观。</p>
</blockquote>
<p>同样的道理，如果我们和交易同学有合作就应该去了解交易系统的概念和规则。如果和推荐系统合作就该去了解一下召回&#x2F;倒排等概念，买一本推荐系统的书从头看一下，可以不求甚解。如果和会计系统合作就应该了解“有借必有贷，借贷必相等”，甚至可以去考一些会计基础证书。</p>
<p>问出好问题，很重要。只有先让对方听懂你的问题，你才能有好答案。不要沉浸在自己的世界中和别人沟通，要使用别人能理解的词汇去描述或回答问题，以及描述问题的时候携带必要的上下文，尽量给对方提供舒服的交流环境。</p>
<blockquote>
<p>学了新的语言，才能够使用别人能听懂的语言沟通，这样提出的问题才能得到更好的解答</p>
</blockquote>
<h2><span id="22-加班加点事倍功半">22. 加班加点，事倍功半</span></h2><p>专业编程不像几公里的全力奔跑，目标就如宽阔马路的尽头一样清晰可见。而更像黑暗中进行的马拉松，你只有一张粗略的地图。如果蒙头奔着一个方向跑下去，则不太可能成功。你需要保持一个可接受的步速，当你对自己所处的位置有了更多了解之后，就调整你的行程。</p>
<p>同时，你还需要时间来持续学习，让你的专业领域知识保持最新。因此，你不能把你的晚上、周末、假期都用在加班上。<strong>对工作的准备和持续学习才是职业生涯的核心部分</strong>。</p>
<p>工作要像一个专业人员一样：充分准备、付诸实施、观察、反省和改变。专注于你的项目，竭尽所能找到灵活的解决方案，提高你的技能，反省思考你正在做的事情，然后调整自己的行为，不要把所有精力都放在全力奔跑上。</p>
<p><strong>放下鼠标，离开键盘，去走一走，让大脑做一些与创造性相关的事情，听听音乐，休息一下。<strong>只有当你离开电脑之后，你才会发现你解决问题的第一次尝试并不是解决问题的最佳方案。这也是</strong>设计两次</strong>的最佳时机。</p>
<blockquote>
<p>在开发项目时，你会对问题领域了解的越来越多，并有望找到更高效的途径。为了避免无效工作，你必须有足够的时间去观察你手头上的工作，思考你所看到的情况，并随时调整你的行为</p>
</blockquote>
<h2><span id="23-数据是核心">23. 数据是核心</span></h2><p>从站在更远的角度来看，系统一般都是操作数据的工具而已。无论代码量级有多少，处于核心地位的永远是<strong>数据</strong>。而且相对于繁杂的代码，把注意力集中到底层小的多的基本数据集上，会更容易一些。<strong>数据要比代码更加精炼，也更好理解</strong>。要想读懂程序，最为困难的就是厘清哪些数据之间是相互关联的。</p>
<p>就如同代码的优化升级都还好做一些，但涉及到数据结构的变化，解决起来就会困难得多，要考虑双写、同步、迁移、一致性。数据构成了系统的核心，数据是系统中最重要的部分，代码可以是一坨便便，但数据一定要清晰且合理。所以对数据的设计要给予足够的重视。</p>
<blockquote>
<ol>
<li>系统设计时优先考虑数据模型的设计</li>
<li>上手新服务时优先查看数据存储的实现。这时候如果是非结构化存储，会有理解成本。</li>
</ol>
</blockquote>
<h2><span id="24-根据投资回报率roi进行决策">24. 根据投资回报率(ROI)进行决策</span></h2><p>测试是一件 <code>ROI</code>很高的事情，投入 4 个小时时间编写测试用例。却可以省下 8 小时的问题排查时间，投资回报率高达 200%。</p>
<p>如果发布上架对投资方是至关重要的，那么花费半年才能得到的完美系统相比于花费 2 个月的 <code>MVP</code>版本”，<code>ROI</code>就要低很多。发布了能用的版本，根据用户反馈适当调整，更能活得下去。</p>
<p>系统的升级改造，主要是时间投入和预计收益是否能适当。即使一个系统架构不佳，但是修改频率很低，那么就可以先放置在那里，不去管他。先把时间投入其他重要事情上，如果没有其他事情可做，那另当别论。</p>
<h2><span id="25-拉伸关键维度发现设计中的不足">25. 拉伸关键维度，发现设计中的不足</span></h2><p>我们的设计一般都是基于当前需求、当前熟悉的技术、预期的数据量和当前性能要求等实现的。</p>
<p>在设计的时候，我们可以来拉伸解决方案中的关键维度，看看哪些方面会遭到破坏。比如，如果用户量越来越多，当前系统是否能承载；如果每天处理的交易数据量越来越多，是当前的十倍百倍会如何；如果数据必须要保存 6 个月而非一周时，当前存储是否满足；通过这些手段，这样我们就能发现设计的不足。</p>
<p>我们暂且简称其为<strong>无限法</strong>，即尝试系统中的关键维度扩展到无限大的时候，会发生什么。</p>
<p>设计归设计，实现归实现。当前数据量少，我们可以用 <code>mysql</code>实现检索，但是要保留以后检索维度或数据增多之后替换成 <code>ES</code>或者搜索中台的能力。对 <code>ES</code>操作的代码在这次实现中可能一行都不会写，但是要保证以后对于扩展来说是易于添加&#x2F;切换的。</p>
<p>这就涉及到对好代码(好设计)的标准，就是：<strong>是否能轻而易举的修改它</strong>。主要有两点：</p>
<ul>
<li><p>可读性：首先要读懂，才能谈修改</p>
</li>
<li><p>可扩展性：能够轻易找到修改点，快速做出修改。并且基于开闭原则，只增加而不修改原有逻辑才能避免引入错误</p>
</li>
</ul>
<h2><span id="26-编码标准的自动化">26. 编码标准的自动化</span></h2><p>研发流程中引入 <code>CI/CD</code>流水线，代码不符合规范就要中止流程，测试覆盖度不够或者测试用例失败都要中止流水线。代码检查和发布上线都使用流水线完成，<strong>避免人为犯错的机会</strong>。</p>
<p>越早发现 <code>bug</code>，修复成本越低。因此我们希望在编码阶段就能发现 <code>bug</code>，发现 <code>bug</code>的方式就是自动化测试，可能是单测，也可能是接口测试。</p>
<p>要想实现这个目标，需要：</p>
<ol>
<li><p>非侵入式的测试框架。</p>
</li>
<li><p>一套能够与测试相协调的部署系统。</p>
</li>
<li><p>团队成员乐于执行自动化测试。</p>
</li>
<li><p>编写易于测试的代码 - 无状态的代码更易于测试。</p>
</li>
</ol>
<blockquote>
<p>让所有的线上变更都走流程，即使你认为加行日志不会有问题，但是也可能会因为空指针而 <code>core dump</code></p>
</blockquote>
<h2><span id="27-靠谱和信用是我们的资产">27. 靠谱和信用是我们的资产</span></h2><p>工作就是树立个人影响力的过程，不管是你写的代码多牛逼，解决了多复杂的问题，这是一方面。但总还是有一些软素质直接影响评价和定位。比如：</p>
<ul>
<li><p>问题的解决者和终结者：只会抱怨还是低头去解决问题</p>
</li>
<li><p>事事有回应，不管办不办得成：不丢消息不只是对系统的要求，也是对个人的要求</p>
</li>
<li><p>不要有太强自尊心，别人跟你你说：你这个实现有问题。第一反应不要是反驳</p>
</li>
<li><p>如果不能如期履行承诺，请尽快告知受影响的人，以便对方调整计划。完不成不是一件丢人的事情。</p>
</li>
<li><p>把事做完：系统重构新功能上线，老服务没下掉是否是完成？</p>
</li>
</ul>
<h2><span id="28-应该了解设计模式的原则">28. 应该了解设计模式的原则</span></h2><p>这些原则耳熟能详，但是是否做到了呢。过上几个月问一下自己。</p>
<ul>
<li><p><code>SOLID</code>原则：单一职责、开闭原则、里氏替换、接口隔离、依赖倒置</p>
</li>
<li><p><code>KISS</code>原则：<code>Keep it Simple and Stupid</code>、<code>Keep it Short and Simple</code>、<code>Keep it Simple and Straightforward</code></p>
</li>
<li><p><code>DRY</code>: <code>Dont Repeat Yourself</code></p>
</li>
<li><p><code>LoD</code>原则: 最少依赖</p>
</li>
</ul>
<h2><span id="29-了解-unix-哲学">29. 了解 Unix 哲学</span></h2><ul>
<li><p>模块原则：使用简洁的接口拼合简单的部件，每个模块做好一件事儿。</p>
</li>
<li><p>清晰原则：清晰胜于机巧，代码首先是给人看的，其次才是给机器执行。</p>
</li>
<li><p>组合原则：设计时考虑拼接组合，类似于 把每个程序都写成过滤器：和 shell 管道一样，一个函数的输出可以作为另一个函数的输入。能组合就不要耦合。</p>
</li>
<li><p>分离原则：策略同机制分离，接口同引擎分离。</p>
</li>
<li><p>简洁原则：设计要简洁，复杂度能低则低。</p>
</li>
<li><p>吝啬原则：除非确无它法，不要编写庞大的程序。避免不必要的代码和逻辑，保持精简。</p>
</li>
<li><p>透明性原则：设计要可见，以便审查和调试。</p>
</li>
<li><p>健壮原则：健壮源于透明与简洁。</p>
</li>
<li><p>表示原则：把知识叠入数据以求逻辑质朴而健壮。代码的复杂度应该在数据中，而不是代码中。</p>
</li>
<li><p>通俗原则：接口设计避免标新立异。“+”应该永远表示加法，而不是除法。</p>
</li>
<li><p>缄默原则：如果程序没什么好说的，就保持沉默。</p>
</li>
<li><p>补救原则：出现异常时，马上退出并给出足量错误信息。</p>
</li>
<li><p>经济原则：宁花机器一分，不花程序员一秒。</p>
</li>
<li><p>生成原则：避免手撕, 尽量编写程序去生成程序。</p>
</li>
<li><p>优化原则：雕琢前先要有原型，跑之前先学会走。</p>
</li>
<li><p>扩展原则：设计着眼未来，未来总比预想来得快。</p>
</li>
</ul>
<h2><span id="30-在责备别人之前先检查自己的代码">30. 在责备别人之前先检查自己的代码</span></h2><p>开发人员通常难以相信自己的代码会出错，绝不可能出错，即使出错了，也必定是编译器出问题了。</p>
<p>如果我们使用的工具&#x2F;库&#x2F;框架是被广泛使用的，那就几乎没有理由怀疑它会出错。如果发生了不符合预期的表现，那就首先怀疑自己的代码：用桩代码进行调用调试，围绕可疑代码编写测试用例，检查版本库版本号，检查配置是否生效等等。</p>
<p>如果其他人报告说有问题，而你无法复现的时候，那就走过去看看他们到底是怎么使用的。他们可能进行了你未曾预料的操作，或者采用了不同的操作次序。排除掉一切不可能之后，剩下的即使多么不可能，即使你的代码看起来没问题，也只能是真相。</p>
<h2><span id="31-编写具有领域语言的代码">31. 编写具有领域语言的代码</span></h2><p>先看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;int, Map&lt;int, int&gt;&gt; portfolioIdsByTraderId</span><br><span class="line"></span><br><span class="line">If portfolioIdsByTraderId.get(trader.getId()).containsKey(portfolio.getId()))</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看起来像是从 <code>trader</code>中取 <code>id</code>，然后用它从一个….，最后看起来是判断<code>protfolio</code>的<code>id</code>是否存在于这个<code>map</code>中，那<code>portfolioIdsByTraderId</code> 是什么结构呢？ 奥，它是个嵌套<code>map</code>…<br>从另一份代码中，你看到的是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If trader.canView(portfolio) &#123;…&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种情况下就不用挠头，也不需要知道它内部到底嵌套了几层 <code>map</code>，因为那是 <code>trader</code> 的事情，与你无关。<br>我们努力的方向就是将现实世界映射到有限的数据结构中，这就需要用户自定义类型，如果你的代码中包含类似 <code>trader</code> <code>portfolio</code> 这样的概念，你就可以使用他们的名称来建模，而不是使用基本数据类型复杂嵌套表述你的目的。不要有基本类型偏执，不要固执的非要使用基本类型(如 <code>map</code> <code>array</code> <code>int</code>等).</p>
<p>否则你怎么知道这个 <code>int</code> 代表了 <code>trader</code>，那个 <code>int</code> 代表了 <code>portfolio</code>，这就是在用一种加密的方式在编码，除了你自己，谁都看不懂；可能明天你自己也就看不懂了。</p>
<h2><span id="32-最好的注释是软件设计架构文档">32. 最好的注释是软件设计架构文档</span></h2><p>前面有两条我们提到，又要好好写注释，又不要写注释。因为注释和注释是不一样的，有意义的注释永不嫌多。从另一个角度看，代码里的注释都是补丁，是碎片化的，局部的注释很难推导模块整体的顺序及耦合关系。整个项目思路的重要性远甚于穿插在代码中的几行注释。</p>
<p><strong>文档建设和技术沉淀比我们想象的还重要</strong>，刨除交接困难的影响以外，没有文档建设的项目一般在质量和架构上也会是一团乱麻。就跟没有地图的路径规划一样，没有文档建设的系统发展也会极度追求短期效益，最终走向混乱。</p>
<p>好好写代码注释，说明你是一个不错的程序员。能够好好写架构设计文档，把各个模块交代清楚，同时代码内也能好好写注释，那应该可以“配享太庙”。</p>
<h2><span id="33-越早写单元测试越好">33. 越早写单元测试越好</span></h2><p>测试既可以是狭义的单元测试，也可以是广义上的功能回归测试。除了单测对质量的保障之外，单元测试还能够帮助改善设计，因为不好测试的代码一般意味着代码结构不好; 可能是引用了全局变量、也没有使用依赖注入导致难以 <code>mock</code>、也可能是没有针对接口编程；函数内部随意调用 <code>time.Now()</code> 导致测试用例不稳定等等。</p>
<p>问题越早被发现，解决的成本越低。单元测试是最早能发现 <code>bug</code>的手段，同时测试带来的边际成本是很低的，只要写一次，就可以永远为你保驾护航。</p>
<h2><span id="34-没有什么能够阻止项目成为屎山">34. 没有什么能够阻止项目成为屎山</span></h2><p>你的代码会随着新功能的增加，以及新技术组件的引入，技术债务会逐步推迟并积压，代码也一定会腐化，因此没有什么办法能够阻止项目腐化，最终也一定会变为我们曾经厌恶的屎山。不如我们妥协一些，接受它最终会变烂，只不过要让他腐化的慢一些、再慢一些。以及做好故障隔离，即使部分功能出了问题能够限制影响范围，不要雪崩。</p>
<p>让服务稳定的跑起来，支撑业务迭代的时间久一些，即使出了问题也能及时发现并解决，把日志打清楚清楚一些，定位能够快一些。做到这些，就善莫大焉了。永远没有正确架构，你永远无法偿还完所有的技术债务，如同你永远不会设计出完美的界面，请避开完美主义的陷阱，永远没有完美的代码，能够满足当前需求，又为未来不管是自己还是他人留有扩展空间，就很好了。</p>
<p>我们能够做到的就是<strong>减缓复杂度增长的速率</strong>，通过 <strong>《整洁的代码》</strong>、<strong>《整洁的架构》<strong>和持续的</strong>《重构》</strong>，达成写更好的代码的目的。如果项目经过几年不得不重构了，那就大胆推倒重构好了，因为架构都是对过去经验的总结，无法预计业务的发展，站在几年后的时间节点回看，重构也是自然的，要不然怎么创造新的岗位需求呢。</p>
<h2><span id="35-要不断学习有针对性的勤加练习">35. 要不断学习，有针对性的勤加练习</span></h2><p>互联网唯一不变的就是变化，技术的出现也是层出不穷，知识的边界也是难以触达。唯有不断学习，才能保持竞争力。</p>
<p>阅读书籍、博客和技术网站，或者为自己找一个导师，可能 <code>Ta</code> 并不承认有你这个学生。导师可能是技术领域的大拿，也可能是网上的技术博主，或者是线下技术分享的讲师，也可能是 <code>B</code>站上的一位 <code>Up</code>主。他是谁并不重要，重要的是你要从他身上学到些什么。</p>
<p>了解你使用的框架和库。读懂他们的运作方式，你会使用的更好。这样你也有机会看到那些聪明人写下的并经过审查的代码。</p>
<p>当你犯错时，或者修复一个 <code>bug</code>，或者遇到问题时，试着真正去了解到底发生了什么。多问几次 <code>Why</code>，多往下追问几层，尝试找出根本原因。</p>
<p>多分享，只有分享才会让你真正了解底层原理。准备分享的过程就是不断追问自己为什么的过程，正因为你不知道为什么所以才需要查阅更多的资料来搞明白。能讲出来三分，说明你懂了七分。</p>
<p>学习那些能改变你的东西，学习那些能改变你行为的东西。不要在自己已经是专家的领域重复练习，去完成那些超出你当前能力的任务，尽力去做，在任务中和任务后分析你的表现情况，改正错误。</p>
<p>保持好奇，尝试找到自己的一套方法论，这套方法论能指导你快速了解一个复杂软件具体是如何工作的；</p>
<p>定期复盘，复盘不只再揭开伤疤撒把盐，更多看是否能有新的输入。比如上个季度做的一项工作，如果以现在的视角再去看一下，是否可以做的更好。</p>
<p>学习的东西不一定跟技术相关，如果学习所从事领域的知识可能会让你更好的理解需求、更快的解决业务问题、甚至于能够让你更充足更开心，那就去做。</p>
<p>不要把所有时间都用在工作, 毕竟，工作之余就应该是生活。</p>
<h2><span id="36-了解你的局限性">36. 了解你的局限性</span></h2><p>你的资源是有限的：</p>
<ul>
<li><p>你每天只有 8 个小时时间可以用在工作上</p>
</li>
<li><p>你跑步的上限是 10KM，最多打球 2 小时，否则容易拉伤</p>
</li>
<li><p>你的系统只能承载一万的 <code>QPS</code></p>
</li>
<li><p>你的机器带宽只是千兆网卡, 只能传输 100MB</p>
</li>
<li><p>你的系统核心数据结构的时间复杂度是 <code>O(n)</code>的</p>
</li>
<li><p><code>RAM</code>一次读取需要耗时 <code>20ns</code>，而磁盘的一次随机读需要耗时 <code>10ms</code>，从北京到广州的耗时是 <code>50ms</code></p>
</li>
</ul>
<p>这些都是你的局限，除了知道你能做什么以外，还应该了解你的局限。这样你才能在排期协调、系统容量预估、大事件扩容、数据量增多导致的查询性能下降等方面做得更好。</p>
<h2><span id="37-使接口易于正确使用难于错误使用">37. 使接口易于正确使用，难于错误使用</span></h2><p>接口的存在是为了方便使用者，而不是接口实现者。如果一个接口需要在<strong>好实现但是不好使用</strong>和<strong>好使用但是不好实现</strong>上选择的话，请毫不犹豫的选择后者。</p>
<p>比如输入框需要用户输入日期，用户怎么知道输入格式呢，用户输入错误该怎么提醒呢？ 更合理的应该提供一个日历组件，用户直接选择就好了，不需要输入。</p>
<p>一个功能需要调用方必须先调用 A()初始化，再调用 B()，最后再调用 C()清理。那何不如把这些步骤封装起来直接暴露一个接口呢。</p>
<p> </p>
<h2><span id="38-编写代码就像余生都要对他负责一样">38. 编写代码就像余生都要对他负责一样</span></h2><blockquote>
<p>想象一个场景：你已经跳槽来公司 3 年了，一个工作日的下午你正在会议室开会，突然接到了上家公司的一个电话，需要你解释一下你所设计的系统架构决策点是什么，以及这个函数为什么要这样写。<br>是不是会很痛苦也会很无奈</p>
</blockquote>
<p>我们进行的所有的工作最终都会落实在代码上，如果你写过的代码需要你对他负责一辈子，那么你会逼着三年前的自己好好命名，将大函数拆分成易于理解的小函数。将类和包结构好好组织，写好注释，并测试自己的代码。设计文档也会好好写，技术债务也会清理而不会任其堆积。因为余生你都需要对这份代码负责，所以你只能将它变得更优美、更灵活、更高效。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
