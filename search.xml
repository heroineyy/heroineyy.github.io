<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cursor meetup chengdu的一些感受</title>
    <url>/posts/Cursor%20meetup%20chengdu%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97/</url>
    <content><![CDATA[<h1 id="一、leerob的分享"><a href="#一、leerob的分享" class="headerlink" title="一、leerob的分享"></a>一、leerob的分享</h1><p>1、知道所以然 基础知识 底层原理</p>
<p>2、一定要尝试并体验新技术</p>
<p>3、一定要经历挫折</p>
<p>4、解决幻觉，事先把设计系统、应用架构环境告诉给AI</p>
<p>5、深入理解mcp 才能使用mcp</p>
<p>6、去<a href="http://x.com/">x.com</a>社交软件看看leerob的上下文原理（多到不同平台看看大佬的对新技术的理解和观点）</p>
<h1 id="二、分享会的有趣信息"><a href="#二、分享会的有趣信息" class="headerlink" title="二、分享会的有趣信息"></a>二、分享会的有趣信息</h1><p>1、项目很大的话 上下文太多 大模型出现问题怎么办？可以让gpt对代码进行拆分</p>
<p>2、阅读代码 ，可以把函数给gpt总结核心、抽取主干再阅读</p>
<p>3、让大模型生成测试数据，根据示例数据生成回答</p>
<p>4、cursor 最适合写工具类和单元测试代码</p>
<p>5、写代码前，提前告诉他环境版本信息，避免写出和当前环境不匹配，导致运行不通过的代码 </p>
<p>6、一些推荐技术或工具网站分享</p>
<p>1）difi-on-qianniu</p>
<p>2）vercel</p>
<p>3）monica</p>
<p>4）deep-wiki（将代码库发给他生成详细的文档）</p>
<h1 id="三、自由交流时间的收获"><a href="#三、自由交流时间的收获" class="headerlink" title="三、自由交流时间的收获"></a>三、自由交流时间的收获</h1><p>1、先修心再修术</p>
<p>2、找不到目标？找到一个技能树，把它填满</p>
<p>3、当下学习什么？拥抱新技术、大胆尝试、但依旧要深挖底层基础，啃大骨头才是我们程序员的核心竞争力</p>
<p>4、简历被拒，面试没有通过？针对找后端项目，可能是项目太过简单面试官看不上，那么就打磨技术多写代码，对自己的项目做进一步优化，事实求是，另外回答问题不笃定出现了“吧”什么的只是面试的大忌，不要把面试官当成傻子，包装的简历一定会被洞察到，写到简历的东西一定要熟悉。</p>
<p>5、关于提升后端技能</p>
<p>首次从工作上面考虑：</p>
<p>1）在工作中想想哪些是重复的工作，哪些环节需要优化、沿着工作的技术做衍生学习 </p>
<p>2）把握时代的风口，提前学小而精的东西，大家都不学或不知道然后你去学的东西，做到60%～70%，取得老板信任将其工作交付于你负责（学习领导里感觉也很重要）</p>
<p>其次从下班后上考虑：</p>
<p>1）找到一个技能树，设定短期目标、一点点把它填满，</p>
<p>2）如何在这个过程取得正反馈？任务拆解，选择自己感兴趣的学习</p>
<p>6、一切皆有可能，向外寻求机会、找到一切可能性、多分享多连接</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Go哲学</title>
    <url>/posts/Go%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[<p>1、Go 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 Goroutine 当作免费的资源，随便用。</p>
<p>2、Go 的并发编程模型用 Goroutine 和 Channel 来替代。Goroutine 和线程类似，Channel 和 Mutex 类似。</p>
<p>3、Channel 的发送和接收操作本质上都是 “值的拷贝”。</p>
<p>4、Go 的理念：用通信来共享内存。与其让多个 Goroutine 争抢同一块内存，不如让它们各自独立，通过 Channel 把需要的数据传递给对方，核心目的是避免数据竞争。</p>
<p>5、Go 参数传递都是值传递。</p>
<p>6、&amp;和*的区别</p>
<ul>
<li><p>&amp;是引用，作用于值类型，用于取地址，如果想要传递一个类型的地址避免值拷贝，就可以在前面加一个&amp;表示取该类型的地址，在函数的参数定义时，记得在参数的类型加上*。</p>
</li>
<li><p>*是指针，用于标记指针类型，或者对地址进行解引用，例如 var a *int  中，a 为指向 int 类型的地址， 若 p 是的类型是指针，*p 表示地址 p 指向的值。</p>
</li>
</ul>
<p>7、GMP 模型</p>
<p>M，内核线程，操作系统内核其实看不见 G 和 P，只知道自己在执行一个线程。G 和 P 都是在用户空间上的实现。每一个 M 持有一个 P，通过 P 来获取 G。</p>
<p>8、Go 语言在高并发场景应用非常广泛，但是 Go 的数据结构大多数都是线程不安全的，也就是说当多个 groutine 同时操作数据会存在数据竞争的问题，比如 Map、Chan 线程并不安全，解决方案可以加锁也可以用好 channel，本质需要通过 synic.lock 来应对并发问题使其同一时间保证只有一个协程用一份数据。</p>
<p>9、组合优于继承，通过 “结构体嵌入”（Struct Embedding）实现代码复用和功能组合。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>博客诞生记</title>
    <url>/posts/%E5%8D%9A%E5%AE%A2%E8%AF%9E%E7%94%9F%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本指南是我搭建这个网站的全过程，让<a href="https://manus.im/share/gEmD0mNtTVLkImBCX4EfVV?replay=1">Manus</a>给我生成的搭建指南，现在把指南全部保留分享给大家，指南很详细，亲测有效，总之，不要畏惧，AI时代，想法落地So Easy！相信自己！Enjoy it ～</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">环境准备</a></li>
<li><a href="#nodejs%E5%AE%89%E8%A3%85">Node.js安装</a></li>
<li><a href="#git%E5%AE%89%E8%A3%85">Git安装</a></li>
<li><a href="#hexo%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">Hexo安装与配置</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE">创建博客项目</a></li>
<li><a href="#%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%9A%E5%88%B6">博客配置与定制</a></li>
<li><a href="#github-pages%E9%83%A8%E7%BD%B2">GitHub Pages部署</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">常见问题解决</a></li>
<li><a href="#%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE">进阶配置</a></li>
</ol>
<hr>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>开始搭建个人博客之前，需要在Windows系统上安装必要的软件环境。本指南将详细介绍每个步骤，确保您能够顺利完成博客的搭建。</p>
<h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><ul>
<li>Windows 10 或更高版本</li>
<li>至少 4GB RAM</li>
<li>2GB 可用磁盘空间</li>
<li>稳定的网络连接</li>
</ul>
<h3 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a>所需软件</h3><ol>
<li><strong>Node.js</strong> - JavaScript运行环境</li>
<li><strong>Git</strong> - 版本控制工具</li>
<li><strong>代码编辑器</strong> - 推荐 VS Code 或 Notepad++</li>
</ol>
<hr>
<h2 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h2><p>Node.js 是运行 Hexo 的基础环境，我们需要先安装它。</p>
<h3 id="步骤1：下载Node-js"><a href="#步骤1：下载Node-js" class="headerlink" title="步骤1：下载Node.js"></a>步骤1：下载Node.js</h3><ol>
<li>访问 Node.js 官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></li>
<li>点击 “LTS” 版本下载（推荐使用长期支持版本）</li>
<li>选择 Windows Installer (.msi) 64位版本</li>
</ol>
<h3 id="步骤2：安装Node-js"><a href="#步骤2：安装Node-js" class="headerlink" title="步骤2：安装Node.js"></a>步骤2：安装Node.js</h3><ol>
<li>双击下载的 <code>.msi</code> 文件启动安装程序</li>
<li>点击 “Next” 继续</li>
<li>接受许可协议，点击 “Next”</li>
<li>选择安装路径（建议使用默认路径）</li>
<li>在功能选择页面，确保勾选以下选项：<ul>
<li>Node.js runtime</li>
<li>npm package manager</li>
<li>Add to PATH（重要：这将自动配置环境变量）</li>
</ul>
</li>
<li>点击 “Next” 然后 “Install”</li>
<li>等待安装完成，点击 “Finish”</li>
</ol>
<h3 id="步骤3：验证安装"><a href="#步骤3：验证安装" class="headerlink" title="步骤3：验证安装"></a>步骤3：验证安装</h3><ol>
<li>按 <code>Win + R</code> 打开运行对话框</li>
<li>输入 <code>cmd</code> 并按回车打开命令提示符</li>
<li>输入以下命令验证安装：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure>

<p>如果显示版本号，说明安装成功。</p>
<h3 id="配置npm镜像（可选但推荐）"><a href="#配置npm镜像（可选但推荐）" class="headerlink" title="配置npm镜像（可选但推荐）"></a>配置npm镜像（可选但推荐）</h3><p>为了提高包下载速度，建议配置国内镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>验证配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>Git 是版本控制工具，用于管理代码和部署博客到 GitHub Pages。</p>
<h3 id="步骤1：下载Git"><a href="#步骤1：下载Git" class="headerlink" title="步骤1：下载Git"></a>步骤1：下载Git</h3><ol>
<li>访问 Git 官方网站：<a href="https://git-scm.com/">https://git-scm.com/</a></li>
<li>点击 “Download for Windows”</li>
<li>下载最新版本的 Git</li>
</ol>
<h3 id="步骤2：安装Git"><a href="#步骤2：安装Git" class="headerlink" title="步骤2：安装Git"></a>步骤2：安装Git</h3><ol>
<li>双击下载的 <code>.exe</code> 文件启动安装程序</li>
<li>点击 “Next” 继续</li>
<li>选择安装路径（建议使用默认路径）</li>
<li>在组件选择页面，建议勾选：<ul>
<li>Git Bash Here（右键菜单集成）</li>
<li>Git GUI Here</li>
<li>Git LFS (Large File Support)</li>
</ul>
</li>
<li>选择默认编辑器（推荐 VS Code 或 Notepad++）</li>
<li>选择初始分支名称：选择 “Override the default branch name for new repositories” 并输入 “main”</li>
<li>调整PATH环境：选择 “Git from the command line and also from 3rd-party software”</li>
<li>选择HTTPS传输后端：使用 “Use the OpenSSL library”</li>
<li>配置行尾转换：选择 “Checkout Windows-style, commit Unix-style line endings”</li>
<li>配置终端模拟器：选择 “Use MinTTY”</li>
<li>其他选项保持默认，点击 “Install”</li>
</ol>
<h3 id="步骤3：验证安装-1"><a href="#步骤3：验证安装-1" class="headerlink" title="步骤3：验证安装"></a>步骤3：验证安装</h3><p>打开命令提示符，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>如果显示版本号，说明安装成功。</p>
<h3 id="步骤4：配置Git用户信息"><a href="#步骤4：配置Git用户信息" class="headerlink" title="步骤4：配置Git用户信息"></a>步骤4：配置Git用户信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些信息将用于提交记录。</p>
<hr>
<h2 id="Hexo安装与配置"><a href="#Hexo安装与配置" class="headerlink" title="Hexo安装与配置"></a>Hexo安装与配置</h2><p>现在我们开始安装和配置 Hexo 博客框架。</p>
<h3 id="步骤1：安装Hexo-CLI"><a href="#步骤1：安装Hexo-CLI" class="headerlink" title="步骤1：安装Hexo CLI"></a>步骤1：安装Hexo CLI</h3><p>打开命令提示符（以管理员身份运行），输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>等待安装完成。</p>
<h3 id="步骤2：验证Hexo安装"><a href="#步骤2：验证Hexo安装" class="headerlink" title="步骤2：验证Hexo安装"></a>步骤2：验证Hexo安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>

<p>如果显示版本信息，说明安装成功。</p>
<hr>
<h2 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h2><h3 id="步骤1：选择博客目录"><a href="#步骤1：选择博客目录" class="headerlink" title="步骤1：选择博客目录"></a>步骤1：选择博客目录</h3><ol>
<li>在您希望存放博客的位置创建一个文件夹，例如 <code>D:\MyBlog</code></li>
<li>在该目录下打开命令提示符：<ul>
<li>在文件夹空白处按住 <code>Shift</code> 键，右键点击</li>
<li>选择 “在此处打开命令窗口” 或 “在此处打开PowerShell窗口”</li>
</ul>
</li>
</ol>
<h3 id="步骤2：初始化Hexo项目"><a href="#步骤2：初始化Hexo项目" class="headerlink" title="步骤2：初始化Hexo项目"></a>步骤2：初始化Hexo项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 <code>my-blog</code> 的文件夹，包含完整的博客项目结构。</p>
<h3 id="步骤3：项目结构说明"><a href="#步骤3：项目结构说明" class="headerlink" title="步骤3：项目结构说明"></a>步骤3：项目结构说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-blog/</span><br><span class="line">├── _config.yml          # 站点配置文件</span><br><span class="line">├── package.json         # 应用程序信息</span><br><span class="line">├── scaffolds/           # 模板文件夹</span><br><span class="line">├── source/              # 资源文件夹</span><br><span class="line">│   ├── _drafts/         # 草稿文件夹</span><br><span class="line">│   └── _posts/          # 文章文件夹</span><br><span class="line">├── themes/              # 主题文件夹</span><br><span class="line">└── node_modules/        # 依赖包文件夹</span><br></pre></td></tr></table></figure>

<h3 id="步骤4：启动本地服务器"><a href="#步骤4：启动本地服务器" class="headerlink" title="步骤4：启动本地服务器"></a>步骤4：启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>或简写为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>打开浏览器访问 <code>http://localhost:4000</code>，您应该能看到默认的博客页面。</p>
<hr>
<h2 id="博客配置与定制"><a href="#博客配置与定制" class="headerlink" title="博客配置与定制"></a>博客配置与定制</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>编辑根目录下的 <code>_config.yml</code> 文件，配置您的博客信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网站信息</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的个人博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;分享技术与生活&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;这是一个基于Hexo搭建的个人博客，记录技术学习和生活感悟&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">技术,博客,生活,学习</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">您的名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL配置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://yourusername.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新页面</span></span><br><span class="line">hexo new page <span class="string">&quot;页面名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>文章将在 <code>source/_posts/</code> 目录下生成，使用 Markdown 格式编写。</p>
<h3 id="文章格式示例"><a href="#文章格式示例" class="headerlink" title="文章格式示例"></a>文章格式示例</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2025-01-27 10:00:00</span><br><span class="line">tags: [标签1, 标签2]</span><br><span class="line"><span class="section">categories: [分类名称]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">这里是文章内容，使用Markdown语法编写。</span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 列表项1</span><br><span class="line"><span class="bullet">-</span> 列表项2</span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文字**</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*斜体文字*</span></span><br><span class="line"></span><br><span class="line">[<span class="string">链接文字</span>](<span class="link">https://example.com</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">图片描述</span>](<span class="link">图片路径</span>)</span><br></pre></td></tr></table></figure>

<h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>Hexo 有丰富的主题生态，推荐几个优秀主题：</p>
<h4 id="1-NexT主题（简洁优雅）"><a href="#1-NexT主题（简洁优雅）" class="headerlink" title="1. NexT主题（简洁优雅）"></a>1. NexT主题（简洁优雅）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next next</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<h4 id="2-Butterfly主题（功能丰富）"><a href="#2-Butterfly主题（功能丰富）" class="headerlink" title="2. Butterfly主题（功能丰富）"></a>2. Butterfly主题（功能丰富）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Fluid主题（现代化设计）"><a href="#3-Fluid主题（现代化设计）" class="headerlink" title="3. Fluid主题（现代化设计）"></a>3. Fluid主题（现代化设计）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-fluid</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">fluid</span></span><br></pre></td></tr></table></figure>

<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>安装一些有用的插件来增强博客功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成站点地图</span></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成RSS订阅</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索功能</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GitHub-Pages部署"><a href="#GitHub-Pages部署" class="headerlink" title="GitHub Pages部署"></a>GitHub Pages部署</h2><p>GitHub Pages 是免费的静态网站托管服务，非常适合托管 Hexo 博客。</p>
<h3 id="步骤1：创建GitHub账户"><a href="#步骤1：创建GitHub账户" class="headerlink" title="步骤1：创建GitHub账户"></a>步骤1：创建GitHub账户</h3><ol>
<li>访问 <a href="https://github.com/">https://github.com/</a></li>
<li>点击 “Sign up” 注册账户</li>
<li>验证邮箱地址</li>
</ol>
<h3 id="步骤2：创建仓库"><a href="#步骤2：创建仓库" class="headerlink" title="步骤2：创建仓库"></a>步骤2：创建仓库</h3><ol>
<li>登录GitHub后，点击右上角的 “+” 号</li>
<li>选择 “New repository”</li>
<li>仓库名称必须是：<code>你的用户名.github.io</code><ul>
<li>例如：如果用户名是 <code>zhangsan</code>，仓库名就是 <code>zhangsan.github.io</code></li>
</ul>
</li>
<li>设置为 Public（公开）</li>
<li>勾选 “Add a README file”</li>
<li>点击 “Create repository”</li>
</ol>
<h3 id="步骤3：配置SSH密钥（推荐）"><a href="#步骤3：配置SSH密钥（推荐）" class="headerlink" title="步骤3：配置SSH密钥（推荐）"></a>步骤3：配置SSH密钥（推荐）</h3><p>为了安全地推送代码，建议配置SSH密钥：</p>
<ol>
<li>打开Git Bash</li>
<li>生成SSH密钥：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>按回车使用默认路径，可以设置密码或直接回车</li>
<li>复制公钥内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在GitHub上添加SSH密钥：<ul>
<li>点击头像 → Settings</li>
<li>左侧菜单选择 “SSH and GPG keys”</li>
<li>点击 “New SSH key”</li>
<li>粘贴公钥内容，点击 “Add SSH key”</li>
</ul>
</li>
</ol>
<h3 id="步骤4：配置Hexo部署"><a href="#步骤4：配置Hexo部署" class="headerlink" title="步骤4：配置Hexo部署"></a>步骤4：配置Hexo部署</h3><p>编辑博客根目录下的 <code>_config.yml</code> 文件，在文件末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署配置</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:你的用户名/你的用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>如果没有配置SSH，也可以使用HTTPS：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/你的用户名/你的用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤5：安装部署插件"><a href="#步骤5：安装部署插件" class="headerlink" title="步骤5：安装部署插件"></a>步骤5：安装部署插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="步骤6：部署博客"><a href="#步骤6：部署博客" class="headerlink" title="步骤6：部署博客"></a>步骤6：部署博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到GitHub</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>或者使用简写命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h3 id="步骤7：访问博客"><a href="#步骤7：访问博客" class="headerlink" title="步骤7：访问博客"></a>步骤7：访问博客</h3><p>部署成功后，访问 <code>https://你的用户名.github.io</code> 即可看到您的博客。</p>
<hr>
<h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><h3 id="问题1：npm安装速度慢"><a href="#问题1：npm安装速度慢" class="headerlink" title="问题1：npm安装速度慢"></a>问题1：npm安装速度慢</h3><p><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用淘宝镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h3 id="问题2：hexo命令不识别"><a href="#问题2：hexo命令不识别" class="headerlink" title="问题2：hexo命令不识别"></a>问题2：hexo命令不识别</h3><p><strong>可能原因：</strong></p>
<ul>
<li>Node.js未正确安装</li>
<li>环境变量未配置</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li>重新安装Node.js，确保勾选”Add to PATH”</li>
<li>手动添加环境变量：<ul>
<li>右键”此电脑” → 属性 → 高级系统设置</li>
<li>环境变量 → 系统变量 → Path</li>
<li>添加Node.js安装路径（通常是 <code>C:\Program Files\nodejs\</code>）</li>
</ul>
</li>
</ol>
<h3 id="问题3：端口4000被占用"><a href="#问题3：端口4000被占用" class="headerlink" title="问题3：端口4000被占用"></a>问题3：端口4000被占用</h3><p><strong>错误信息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: listen EADDRINUSE :::4000</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用其他端口</span></span><br><span class="line">hexo server -p 5000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者找到占用进程并结束</span></span><br><span class="line">netstat -ano | findstr :4000</span><br><span class="line">taskkill /PID 进程ID /F</span><br></pre></td></tr></table></figure>

<h3 id="问题4：部署时权限错误"><a href="#问题4：部署时权限错误" class="headerlink" title="问题4：部署时权限错误"></a>问题4：部署时权限错误</h3><p><strong>解决方案：</strong></p>
<ol>
<li>确保SSH密钥配置正确</li>
<li>检查仓库权限设置</li>
<li>使用HTTPS方式部署</li>
</ol>
<h3 id="问题5：中文文件名乱码"><a href="#问题5：中文文件名乱码" class="headerlink" title="问题5：中文文件名乱码"></a>问题5：中文文件名乱码</h3><p><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置Git编码</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line">git config --global i18n.commit.encoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br></pre></td></tr></table></figure>

<h3 id="问题6：主题安装后样式异常"><a href="#问题6：主题安装后样式异常" class="headerlink" title="问题6：主题安装后样式异常"></a>问题6：主题安装后样式异常</h3><p><strong>解决方案：</strong></p>
<ol>
<li>清理缓存：<code>hexo clean</code></li>
<li>重新生成：<code>hexo generate</code></li>
<li>检查主题配置文件</li>
<li>确保主题版本与Hexo版本兼容</li>
</ol>
<h3 id="问题7：图片无法显示"><a href="#问题7：图片无法显示" class="headerlink" title="问题7：图片无法显示"></a>问题7：图片无法显示</h3><p><strong>解决方案：</strong></p>
<ol>
<li>将图片放在 <code>source/images/</code> 目录下</li>
<li>在文章中使用相对路径：<code>![描述](/images/图片名.jpg)</code></li>
<li>或者安装图片处理插件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="问题8：GitHub-Pages访问慢"><a href="#问题8：GitHub-Pages访问慢" class="headerlink" title="问题8：GitHub Pages访问慢"></a>问题8：GitHub Pages访问慢</h3><p><strong>解决方案：</strong></p>
<ol>
<li>使用CDN加速</li>
<li>考虑使用国内的Gitee Pages</li>
<li>优化图片大小和数量</li>
</ol>
<hr>
<h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><p>如果您有自己的域名，可以配置自定义域名：</p>
<ol>
<li>在 <code>source/</code> 目录下创建 <code>CNAME</code> 文件</li>
<li>在文件中写入您的域名（不带http:&#x2F;&#x2F;）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.yourdomain.com</span><br></pre></td></tr></table></figure></li>
<li>在域名提供商处配置DNS记录：<ul>
<li>添加CNAME记录，指向 <code>你的用户名.github.io</code></li>
</ul>
</li>
</ol>
<h3 id="博客备份"><a href="#博客备份" class="headerlink" title="博客备份"></a>博客备份</h3><p>为了防止数据丢失，建议定期备份：</p>
<ol>
<li>创建备份仓库</li>
<li>将整个博客项目推送到备份仓库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;博客备份&quot;</span></span><br><span class="line">git remote add origin https://github.com/你的用户名/blog-backup.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>添加评论功能：</p>
<h4 id="使用Gitalk"><a href="#使用Gitalk" class="headerlink" title="使用Gitalk"></a>使用Gitalk</h4><ol>
<li><p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gitalk --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在GitHub创建OAuth App：</p>
<ul>
<li>Settings → Developer settings → OAuth Apps</li>
<li>记录Client ID和Client Secret</li>
</ul>
</li>
<li><p>在主题配置中启用Gitalk</p>
</li>
</ol>
<h4 id="使用Valine"><a href="#使用Valine" class="headerlink" title="使用Valine"></a>使用Valine</h4><ol>
<li>注册LeanCloud账户</li>
<li>创建应用，获取App ID和App Key</li>
<li>在主题配置中启用Valine</li>
</ol>
<h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>提高搜索引擎排名：</p>
<ol>
<li><p>安装SEO插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提交站点地图到搜索引擎</p>
</li>
</ol>
<h3 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h3><p>添加访问统计：</p>
<ol>
<li><p><strong>Google Analytics</strong></p>
<ul>
<li>注册Google Analytics账户</li>
<li>获取跟踪ID</li>
<li>在主题配置中添加</li>
</ul>
</li>
<li><p><strong>百度统计</strong></p>
<ul>
<li>注册百度统计账户</li>
<li>获取统计代码</li>
<li>在主题配置中添加</li>
</ul>
</li>
</ol>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>提升博客加载速度：</p>
<ol>
<li><p><strong>图片优化</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-imagemin --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码压缩</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CDN加速</strong></p>
<ul>
<li>使用jsDelivr加速静态资源</li>
<li>配置图片CDN</li>
</ul>
</li>
</ol>
<h3 id="自动化工作流"><a href="#自动化工作流" class="headerlink" title="自动化工作流"></a>自动化工作流</h3><p>使用GitHub Actions自动部署：</p>
<ol>
<li>在博客仓库创建 <code>.github/workflows/deploy.yml</code>：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">source</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;16&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>恭喜您！通过本指南，您已经学会了：</p>
<ol>
<li>✅ 在Windows系统上安装必要的开发环境</li>
<li>✅ 使用Hexo创建个人博客</li>
<li>✅ 配置和定制博客外观</li>
<li>✅ 部署博客到GitHub Pages</li>
<li>✅ 解决常见问题</li>
<li>✅ 进行进阶配置和优化</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="有用的资源"><a href="#有用的资源" class="headerlink" title="有用的资源"></a>有用的资源</h3><ul>
<li><strong>Hexo官方文档</strong>：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li>
<li><strong>主题市场</strong>：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li>
<li><strong>插件市场</strong>：<a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a></li>
<li><strong>Hexo社区</strong>：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></li>
</ul>
<hr>
<p><em>本指南最后更新于：2025年7月29日</em></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的博客</title>
    <url>/posts/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="欢迎来到我的个人博客！"><a href="#欢迎来到我的个人博客！" class="headerlink" title="欢迎来到我的个人博客！"></a>欢迎来到我的个人博客！</h2><p>大家好！欢迎来到我的个人博客。这里将是我分享技术学习心得、生活感悟和有趣想法的地方。</p>
<h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>如果您对我的文章有任何问题或建议，欢迎通过以下方式联系我：</p>
<ul>
<li>邮箱：<a href="mailto:&#x39;&#x33;&#x35;&#49;&#x30;&#x37;&#x31;&#x30;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;">93510710@qq.com</a></li>
<li>GitHub：<a href="https://github.com/heroineyy">https://github.com/heroineyy</a></li>
</ul>
<p>感谢您的访问，希望我的分享能对您有所帮助！</p>
<hr>
<p><em>这是我的第一篇博客文章，更多精彩内容敬请期待！</em></p>
]]></content>
  </entry>
  <entry>
    <title>程序员应该知道的38件事儿</title>
    <url>/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8438%E4%BB%B6%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h2 id="1-简化根本复杂性，消除偶发复杂性"><a href="#1-简化根本复杂性，消除偶发复杂性" class="headerlink" title="1. 简化根本复杂性，消除偶发复杂性"></a>1. 简化根本复杂性，消除偶发复杂性</h2><p>根本复杂性指的是问题与生俱来的、无法避免的困难。比如，协调全国的空中交通，必须实时追踪每架飞机的位置、高度、航速、航向、目的地、降落次序等，才能避免空中和地面冲突。以及还要兼顾因天气原因等航班延误导致的变化。</p>
<p>与之相反，偶发复杂性是解决根本复杂性过程中衍生的，即解决方案本身带来了新问题。比如笨拙的语言语法会导致大家轻易犯错、忘记释放内存导致 <code>OOM</code> 等；比如因为系统设计不佳导致需要更多的对账脚本或监控系统等。</p>
<p>软件开发是为了解决一套高度错综复杂、环环相扣的概念的全部细节问题。之所以存在根本复杂性，就是因为要和复杂、无序的现实世界对接；要准确、完整的识别依赖关系和例外情况；要设计出<strong>完全正确</strong>而不是大致正确的解决方案。这是完全无法避免的根本复杂度。</p>
<p><strong>管理复杂性是软件开发最重要的课题</strong>，可以通过划分子模块、拆解子系统甚至到类的定义、子函数的拆分都是为了将复杂度拆解为简单的部分，隐藏细节，暴露简单的接口。各模块&#x2F;类之间不要跟一团毛线一样混乱。这样才能易于理解，方便扩展。不要逼迫大脑去理解高复杂度的东西，而应该逐步拆解、简化复杂度，方便大脑理解。</p>
<p>我们应该合理划分职责，进而能够编写<strong>高扇入、低扇出</strong>的类。（高扇入表示被很多类依赖，低扇出表示不依赖太多其他类；和高内聚&#x2F;低耦合是一回事儿）</p>
<p>关注根本复杂性，消除偶发复杂性，抽丝剥茧制定解决方案，才是真正的挑战。</p>
<blockquote>
<p>《软件设计的哲学》中对复杂度有更多的讨论</p>
</blockquote>
<h2 id="2-对待技术债务要谨慎"><a href="#2-对待技术债务要谨慎" class="headerlink" title="2. 对待技术债务要谨慎"></a>2. 对待技术债务要谨慎</h2><p>在一次迭代开始时，各项需求看上去安排的张弛有度，但仍无法避免在某个时间承受巨大的进度压力，当你发现必须在 <strong>干得快</strong> 和 <strong>干得好</strong> 之间选择时候，一般都会选择 <strong>干得快</strong>，并提醒自己将来再回头来返工优化。但实际上下一轮迭代总会有下一个问题，将来永不会来。这类久拖不决的任务就是 <strong>技术债</strong> ，<strong>技术债</strong> 就像贷款，短期能获得好处，但你总要付出利息。时间久了，利息也将是一笔难以偿还的债务。因为有债务的存在，新功能的加入将变得困难，而且这些债务也将是 <code>bug</code> 的滋生地。</p>
<p>我们很容易说服自己，当前变更引入的一点点<strong>技术债</strong>并不算什么大问题。就跟破窗效应一样，只要放开了口子，系统会腐化的很快。变坏容易，变好很难。</p>
<p>尽量避免拖欠技术债务，应该要采取<strong>零容忍</strong>策略。如果迫不得已，也要在任务卡片上追踪这笔债务，及时偿还，不要遗忘。</p>
<h2 id="3-分析需求背后的意义"><a href="#3-分析需求背后的意义" class="headerlink" title="3. 分析需求背后的意义"></a>3. 分析需求背后的意义</h2><p>假如用户提出一个需求：设计一架飞行速度在 2.5 马赫(2.5 倍音速)的低成本战斗机。</p>
<p>因为风阻和速度的平方成正比，从 1 马赫到 2 马赫，需要的动力和机身设计有更严苛的要求。但通过追问为什么需要这种类型的战机时，得到的答案是：<strong>为了快速撤离战场</strong>，因为用户想利用速度优势撤离战场。</p>
<p>了解需求之后，可以有更好的方案：通过提升推力重量比，改善战机的加速性能和机动变向性能，用灵巧性取代了对速度的需求。</p>
<p>我们首次遇到的用户需求可能只是用户&#x2F;产品从自己角度想到的一个方案，可能并不是最佳的。可以通过分析用户需求的真正意义，定位真正的问题，尝试提出比用户的建议更好、成本更低的方案。而了解真正需求的办法也很简单：面对用户，不断问为什么。如果用户(也可能是产品)并不能回答你的问题，那么你可以想一下是否需要 <code>Say NO</code>。</p>
<h2 id="4-美在于简单"><a href="#4-美在于简单" class="headerlink" title="4. 美在于简单"></a>4. 美在于简单</h2><p>有些东西是我们在代码中尽力争取的，比如：</p>
<ul>
<li><p>可读性</p>
</li>
<li><p>可维护性、扩展性</p>
</li>
<li><p>开发速度</p>
</li>
<li><p>“难以捉摸”的美的追求</p>
</li>
</ul>
<p>对 <strong>美</strong> 我们都有自己的判断，但 <strong>简单</strong> 一定是它的内在品质。一个应用或者系统无论多么复杂，其中每个单独的组成部分都保持着它的简洁性：简单的模块承担了单一的职责，它包含着同样简单的方法，而且方法的功能如同其名称描述的一样，简单且直接。</p>
<p>不仅每一个组成部分本身的职责要简单，而且与系统其它部分也应该保持着简单的关系。美来自于简单，亦存在于简单。有时因为问题本身很复杂，实现自然也会是复杂的，那就把这些复杂性封装到模块内部，使得模块之间的交互是简单的。</p>
<blockquote>
<p>比如文件系统是复杂的，但是作为封装的模块，对外暴露的只有 <code>open</code> <code>read</code> <code>write</code> <code>lseek</code> <code>close</code> 几个方法。所以这是一个好的设计。如果非要选择，模块拥有一个简单的接口比拥有一个简单的实现更重要。<br>对问题最好的解决方案，就是能够满足该问题的所有需求且最为简单的解决方案。如何衡量简单呢？</p>
</blockquote>
<p>1）是否能快速读懂。</p>
<p>2）是否易于创建，不只是代码敲出来，而是 <code>debug</code> 并写对的时间，复杂的代码通常需要好一阵才能写对。</p>
<p>3）代码的数量。</p>
<p>4）新概念的数量。</p>
<p>简单不是简化，不要把问题想简单了。比如“爬楼梯”算法，递归确实简单，但是当台阶级数比较多时，递归耗时太久，并不是一个好的方案。</p>
<p>更进一步，有时需要简化的是问题而不是方案，当问题难以解决的时候，回头看看这个问题是否合理。比如上面提到的 2.5 马赫的战机。还比如你还没学会使用动态规划或者其他算法解决“爬楼梯”，再回到这个问题来看，现实中台阶数会不会很大呢？并不会，十几级台阶而已，如果计算过程不是在关键路径上，递归看起来又不是不可接受。问题本身是不是个有效问题，远比采用什么方案更重要。</p>
<p><strong>控制复杂度</strong>，是所有编程原则的总则。编程工作的核心就是与复杂度较量。添加功能会让代码复杂，代码复杂，使用起来就困难，项目进展就会变慢。要写好代码，就要尽量拖延代码变复杂的时机，如果非这么做不可的时候再写。即使要写也要尽量消除重复，设法调整架构，使得新添加的功能不会令系统的整体复杂度大幅上升，这才是编程中最难的部分。</p>
<blockquote>
<p>思从深而行从简</p>
</blockquote>
<h2 id="5-少即是多"><a href="#5-少即是多" class="headerlink" title="5. 少即是多"></a>5. 少即是多</h2><p><code>Less is More</code>，虽然是一句老掉牙的格言，但也确实是至理名言。</p>
<p>不要过度实现，不要预计将来会用到，不要觉得这里性能可能会有问题而提早优化，不要做现在不需要但你觉得将来需要的工作。<strong>你编写的代码，只应该解决目前确实存在的这些问题，而不是去解决你正在设想的问题，因为你永远不知道接下来会遇到什么问题。</strong></p>
<p>系统设计应该保留可扩展性，扩展性更多的是在<strong>接口扩展性设计</strong>&#x2F;<strong>外部依赖的可扩展性</strong>等设计层面，这些一般都不需要太早的代码实现。比如接口层面保留引入本地缓存的能力，但先不要写本地缓存的实现代码，因为会增加数据一致性的复杂度和代码复杂度，等以后需要了再添加即可。</p>
<p><strong>最好的代码是不能再删减一行的代码，哪怕是注释。</strong></p>
<h2 id="6-时刻想着删减代码"><a href="#6-时刻想着删减代码" class="headerlink" title="6. 时刻想着删减代码"></a>6. 时刻想着删减代码</h2><p>删除一行代码带给我的成就感要多于增加一行代码。<strong>代码是负债，而不是资产</strong>，对于增加代码我们要吝啬，用新增代码量来衡量工作是愚蠢的。新增的代码都需要维护，而且代码都可能会出错，通过删减代码来提升代码质量也是一种尝试，能用 8 行代码实现的就不要用 10 行。</p>
<p>我们在局部或服务整体重构之后，老代码没有下掉，意味着运维责任多了一倍，这都是负债，我们并没有比重构前变得更轻松。 当然并不是只有重构才能下线代码，冗余的逻辑、无效的代码、不再使用的接口功能等等都是可以删减的代码；实在不济，去掉一些无效或错误的注释也是一份功劳。</p>
<p>运行不到的代码是不管用的，称为死代码。如果发现某段代码已经没人用了，而且可以安全的删掉，这应该是个值得高兴的事情，应该比你新写代码更值得高兴，因为你在不影响功能下缩减了代码量，减少了维护成本。</p>
<p>当然，删减代码并不会被纳入 <code>OKR</code>目标中，但正如运动能够减脂增肌一样，这就是对程序员而言<strong>难而正确的事</strong>。</p>
<h2 id="7-故障终究会发生"><a href="#7-故障终究会发生" class="headerlink" title="7. 故障终究会发生"></a>7. 故障终究会发生</h2><p>机械硬盘的平均无故障工作时间是 3 年，也就是说有 1000 多块硬盘的机房每天都会有故障发生。硬件会出错，于是增加冗余资源提升系统可靠性，虽然可以避免单点故障导致的错误，但更多的硬件会有更大的概率故障。</p>
<p>软件也会出错，于是增加额外的监控程序，但监控程序也是软件，一样会出错。</p>
<p>人无完人，我们也会犯错，因此我们把操作和处理都变成自动化。自动化虽然降低了主动犯错的概率，却增加了错误被忽略的概率。何况任何自动化应对变化的能力远不及人类，于是又为自动化增加监控，结果是更多的软件，更多的故障率。</p>
<p>所以我们不得不承认：系统中必然存在不同形式的故障隐患，无论如何都无法彻底消灭。只有承认这一点，我们才能对特定的故障设计对策，就比如汽车工程师知道交通事故无法避免，所以设计了 安全带、气囊、撞击缓冲区等来保护乘客。因此你的系统也应该设计预防措施来限制故障，可能是限流、熔断、降级、异常上报，甚至是数据恢复脚本。</p>
<p>不应该惧怕故障，也不应该像鸵鸟把头插进沙子里一样对故障视而不见。</p>
<h2 id="8-不要忽略那个错误"><a href="#8-不要忽略那个错误" class="headerlink" title="8. 不要忽略那个错误"></a>8. 不要忽略那个错误</h2><blockquote>
<ol>
<li>一条错误日志</li>
<li>用户反馈的一个不符合预期的 Case</li>
<li>代码中对错误的处理</li>
<li>数据库中的数据不符合预期<br>如果你选择忽略类似上面的一个错误，对其视而不见，假装一切都没发生，那你就是在背负巨大的风险。不顾红灯亮起，继续前行，结果只会招致更大的损失，要在时机初现的时候就动手，把损失减少到最小。</li>
</ol>
</blockquote>
<p>编译器的警告不要忽略，<code>codecc</code>的警告不要忽略，对每个调用后的错误检查不要省略。错误才是常态，不要忽略任何错误，因为一切都正常实在是小概率事件。</p>
<h2 id="9-问题要追踪到根本原因"><a href="#9-问题要追踪到根本原因" class="headerlink" title="9. 问题要追踪到根本原因"></a>9. 问题要追踪到根本原因</h2><ul>
<li><p>不是稳定复现的，重试没问题就忽略了</p>
</li>
<li><p>看板数据有一些异常波动，查起来麻烦，反馈一下得了</p>
</li>
<li><p>不是我服务的问题，客户端或者外部系统的问题，先不管了</p>
</li>
<li><p><code>QA</code>反馈了个 <code>bug</code>，在代码里加了个 <code>if</code>判断处理了一下就给放过了</p>
</li>
</ul>
<p>等等很多只解决了问题表面，而没有根本解决问题。多问“为什么”？直到查明真正的原因。计算机不会撒谎，也不会骗你，所有不符合你预期的行为都值得追查一下，要不就是程序或数据哪里错了，要不就是你的预期错了。不管修正哪一个错误，都是有意义的。</p>
<p>比如最近在业务上，用户反馈购买会员后视频试看结束仍然出蒙层无法播放，分析发现是客户端从后端没有获取到购买成功的信息而拦截，但客户端并没有请求发出和响应的日志。一切都很诡异，如果选择让用户重装一下也是能恢复的。但如果继续追查原因，会发现是客户端对登录态判断逻辑有问题，导致没有发请求。所以用户不能看的根本原因是登录态判断有问题。但凡中间断了没有追查到底，都不能揪出根因。</p>
<p>如果过往经历中没有抓耳挠腮、茶饭不思的追查过几个问题，是有点不完整的。只有在追查根本原因的过程中，才能学到东西并且印象深刻。</p>
<h2 id="10-营地法则：要让离开时的营地比进入时干净"><a href="#10-营地法则：要让离开时的营地比进入时干净" class="headerlink" title="10. 营地法则：要让离开时的营地比进入时干净"></a>10. 营地法则：要让离开时的营地比进入时干净</h2><blockquote>
<p>努力留下一个比你发现时更好的世界 - Robert<br>当你发现地上有脏东西，不管是谁造成的，都要把它清理干净。提交代码时同样如此，只需要 <code>commit</code> 提交时好于 <code>checkout</code> 时即可，你可能仅仅改进了一些变量命名的可读性，或者把长函数拆分成两个短函数；你可以是打破了一个循环依赖，或者增加了一个接口解耦策略和实现细节。</p>
</blockquote>
<p>做的事情可大可小，但是要变好。</p>
<blockquote>
<p>具体可实施的小步改进可参照《重构》</p>
</blockquote>
<h2 id="11-多问自己：用户会怎么做？"><a href="#11-多问自己：用户会怎么做？" class="headerlink" title="11. 多问自己：用户会怎么做？"></a>11. 多问自己：用户会怎么做？</h2><p>外网用户没有程序员的意识和能力来解决问题，也不会认可程序员使用的界面模式和提示信息；因此你在界面底部的一次错误提示，用户可能根本就看不见；同时，用户也不会按下 <code>F12</code>看一下接口调用是否正常。</p>
<p>要想知道用户的真实想法，最好就是观察一个用户的完整操作。给他一个 <code>APP</code>，看他完整的操作轨迹。你要一直问自己：为什么他要那样做？为什么他不那样做？</p>
<p>不要用用户访谈代替观察用户，因为他们访谈的表述和操作之间会有巨大差异。用户在使用你的应用时，在你看来就是个“傻子”。直接观察用户是获取需求的最佳途径，用户到底想要什么？与其闷头猜测，不如花一小时去仔细观察。</p>
<p>敬畏外网用户的反馈，一条外网反馈意味着 1000 个用户遇到了问题。不要无视他们，他们使用并乐于反馈问题，我们要珍惜并积极响应。每一次用户反馈问题的解决，都是提升用户满意度的最有效举措。</p>
<p>如果你在滴滴就去当一名司机体验几天，看一下接送流程是否有优化空间。如果在美团就当一名骑手，加入线下骑手团，问一下骑手们接送单过程是否有问题。如果你不是一名游戏玩家，你就不知道这个游戏做的到底怎么样。</p>
<blockquote>
<p>当然，也不可能所有人都去当司机或者抓人过来搞测试，但是总有其他办法：</p>
<p><em>比如滴滴建设了“听音工具”，让一线研发可以去听客服解决用户进线的录音，知道用户会有哪些问题，客服是如何解决的。</em><br>有千万用户的应用都会建设一个好的埋点系统，好好分析用户点击轨迹行为。这样的边际成本为 0，而且还很客观。</p>
</blockquote>
<h2 id="12-设计两次"><a href="#12-设计两次" class="headerlink" title="12. 设计两次"></a>12. 设计两次</h2><p>软件设计不是一件简单的事情，所以你对如何构建模块的第一个想法不太会是一个好的设计。多做一个备选方案，对比它们，一定会对你有所启发。尝试选择那些彼此截然不同的方法，这样你会学到更多。当然，最重要还是要考虑上层软件的易用性。</p>
<p>对比多个方案，挑选最佳方案，或者整合推动产生最佳方案。多否定自己，多从使用者角度考虑是否合理。设计两次并不会浪费太多时间，设计上浪费的两个小时，相比实现需要的两周而言，不值一提。今天设计好之后，先放在那，切换一下头脑，等待灵光一现看是否有更合理的方案。</p>
<p>但我们大家都是聪明人，我们会觉得没有必要<strong>设计两次</strong>，因为第一次的设计就是<strong>天才的杰作</strong>。但软件设计是一件很难的事情，没有人第一次就做对，所以：尝试设计两次。</p>
<h2 id="13-对代码审查好一点"><a href="#13-对代码审查好一点" class="headerlink" title="13. 对代码审查好一点"></a>13. 对代码审查好一点</h2><p>你可能不喜欢代码审查 <code>Code Review</code>，就跟不喜欢让别人看到你内裤的颜色一样。但我们应该知道，代码审查不仅仅是更正代码错误，其目的还是<strong>共享知识</strong>、建立统一的代码指导标准。代码审查的时候态度要温和，确保评语是有建设性的，不是刻薄的。同样，对评审意见的回复也不应该是“设计如此”&#x2F;“这次先这样”等无意义的回复。</p>
<p>应该月度组织一场“代码审查会议”，在会议上畅谈“代码为什么这样写”和“怎么写可以更好”，可以针对一个命名、一个范式、一个循环判断、单测是否有效、数据库设计是否合理、领域模型是否正确、代码分层和模块划分是否合适等等问题充分讨论。如果这个过程中有<strong>点心</strong>和<strong>饮料</strong>，那代码审查的过程会充满乐趣，并且值得期待。</p>
<h2 id="14-良好的命名就是最佳的文档"><a href="#14-良好的命名就是最佳的文档" class="headerlink" title="14. 良好的命名就是最佳的文档"></a>14. 良好的命名就是最佳的文档</h2><p>编程无非就是在对 26 个字母排列组合，如何能让别人读懂你的代码，除去更大范围的模式设计之外，在一个屏幕可见范围内，良好的变量和函数命名是最有助于让读者看懂你代码的实现。</p>
<ul>
<li><p>不要写注释：如果必须添加注释才能说明一段代码的含义，那就拆分成多个子函数，用函数名来表述注释要表达的含义。</p>
</li>
<li><p>不要为了少打几个字母而缩减名称。<code>x</code> <code>y</code> <code>xr</code> <code>rn</code> 等，除非它的作用域只有两三行。</p>
</li>
<li><p>不要将多种命名习惯混用，要保持一致，比如昵称不要混用 <code>nick</code> 和 <code>name</code>，在全场景使用一个就好; 另外，符合惯用法，比如 <code>empty()</code> 方法，一般场景用于判断 <strong>是否为空</strong>，那么就不要给这个方法再赋予<strong>清空该容器</strong>的动词含义。</p>
</li>
<li><p>词要达意，存储名称的集合，不要叫 <code>nameList</code>，直接 <code>names</code>就好。尽量不要使用 <code>itemData</code>, <code>userInfo</code> 等含义很广，必需要深入看实现才能懂的命名。</p>
</li>
<li><p>名称的长短和名称的作用域成正比。短循环内局部变量就用短命名。整个函数声明周期的命名就要长一些。</p>
</li>
</ul>
<p>命名最重要的就是精确性和一致性。不要过于笼统或者模糊。对重复使用的概念，保持一致的命名。不要一会儿 <code>title</code> 一会儿 <code>name</code></p>
<blockquote>
<p>对变量的命名要像给自己孩子起名一样慎重，好的名字十分重要，但往往并非唾手可得。</p>
</blockquote>
<h2 id="15-要写注释"><a href="#15-要写注释" class="headerlink" title="15. 要写注释"></a>15. 要写注释</h2><p><strong>注释的目的是补充代码所不能表达的意图。如果能通过调整代码结构、重命名函数和变量就能解释清楚的就不要写注释。代码应该能向下一个接替我的程序员解释自己</strong>，注释并非总是邪恶的，它们和代码结构一样重要。在代码顶部写上注释，用来说明代码要完成什么事情；在代码内部加上注释，可以让其他开发人员知晓如何修复或扩展这些代码。对复杂项目来说，通过阅读代码来了解其行为是不现实的, 注释是快速了解项目的入口。</p>
<p>设身处地的为以后的读者或者 15 分钟前的自己想一想：你希望知道什么？</p>
<p>注释主要将代码中不明显的东西揭示给读者：</p>
<ul>
<li><p>不要写行内注释，使用有意义的命名来代替行内注释。</p>
</li>
<li><p>不要为显而易见的代码添加注释</p>
</li>
<li><p>不要注释旧代码，直接删掉它</p>
</li>
<li><p>不要写<strong>在做什么</strong>，而要写<strong>为什么</strong>。比如这个注释就能解决读者疑惑：由于需要尽可能减少网络请求的次数，代码处理变得复杂了。</p>
</li>
</ul>
<p>审阅代码时，如果你发现一段逻辑理解起来很吃力，而代码本身也没有太多优化空间，请不要迟疑，勇敢表达出你对于<strong>注释</strong>的需求吧！</p>
<h2 id="16-早部署，常部署"><a href="#16-早部署，常部署" class="headerlink" title="16. 早部署，常部署"></a>16. 早部署，常部署</h2><p>软件开发中，部署和调试我们往往会被放在项目的最后去做，前面的步骤我们都在假定一切都是正常的。协议会按照约定实现，正在做的功能就是用户想要的，只需要等待最后时刻全部拿出来，一定能惊艳众人。</p>
<p>但是真到了交付的时候会发现问题很多：协议和预期的不一致、产品说这个功能不是 Ta 想要的。这个时候不是陷入需求撕扯中，要不就是加班加点的修改。何其痛苦。这时候不如把开发过程切开一下，完成一些功能之后我们就部署联调一次，这会确保我们已经完成的工作是有效而且可控的。</p>
<p>早部署、早交付、常部署、常交付，越早部署就越能发现问题，不要堆到最后一把梭哈。</p>
<h2 id="17-不要怕搞砸"><a href="#17-不要怕搞砸" class="headerlink" title="17. 不要怕搞砸"></a>17. 不要怕搞砸</h2><p>你可能有过这样的经历：</p>
<ul>
<li><p>基础代码相当不稳定；系统结构差，更改一样东西总会破坏另一个不相关的功能；</p>
</li>
<li><p>无论增加什么功能，编码人员的目标都是尽可能少的改动，每次到了发布时间，都提心吊胆；</p>
</li>
<li><p>耦合严重，很难找到修改切入点。每次的修改都会影响到老功能；</p>
</li>
</ul>
<p>任何作出系统更改的理由都如此痛苦。因为系统病了，它需要一个医生。你知道系统出了问题，但是你会担心你的优化修改是否会引入新的问题，你会秉持 <strong>能用就行</strong> 的原则得过且过。这个时候请大胆一些，不要怕搞砸，就像手术一样，为了治疗疾病总是需要几道切口。切口会愈合，系统也是这样。花在重构&#x2F;优化上的时间能够在项目生命周期里得到数倍的回报。</p>
<p>重构过程中，你需要重新定义内部接口、重新设计模块，以及采用减少依赖的方式简化代码。通过这些工作，可以显著降低代码的复杂度。</p>
<p>同时保持 <strong>测试完备</strong>，重构的前提是你有测试用例证明你的重构是安全的，不管是回归测试还是 <code>diff</code>测试，这些重构的改动都应该在可控范围内。</p>
<p>不要犹豫，如果你觉得系统需要优化，不管大小，请勇敢前行。</p>
<h2 id="18-决定重构之前，先想想这能不能比原来好一倍"><a href="#18-决定重构之前，先想想这能不能比原来好一倍" class="headerlink" title="18. 决定重构之前，先想想这能不能比原来好一倍"></a>18. 决定重构之前，先想想这能不能比原来好一倍</h2><blockquote>
<p>上一条我们鼓励优化重构，是的，这一条却希望你慎重，这很矛盾<br>简单来看，程序员分为两类：</p>
</blockquote>
<ul>
<li><p>喜欢<strong>渐进的思考</strong>，总是基于现有方案来思考每一个问题，通过调整现有方案来解决新的问题</p>
</li>
<li><p>总喜欢用一个系统解决所有问题，而不只是当前这个问题，因此，只要有机会，他们就想<strong>从头设计</strong>方案</p>
</li>
</ul>
<p>这两种倾向走向极端，都会造成灾难。如果所有修复都是小修小补，那你会将自己困住，无法从更大维度思考问题，他们的说辞总是“不可能”、“时间不够”等。反之，如果所有方案都需要从头开始，仅凭一个单独的用例，就决定重做整个系统那你会将前一套架构带给你的知识丢掉，陷入<strong>原地转圈&#x2F;不断重构</strong>的过程，这类同学只从解决方案出发，来论证需要重构，而没有能够从当前需要解决的问题出发。凡事不从问题出发的提议，都是值得怀疑的。</p>
<p>如何决定选择<strong>小的优化修复</strong>还是<strong>重构</strong>呢？ 那就是：<strong>重构&#x2F;优化之后能不能比原来好一倍</strong></p>
<ul>
<li><p>研发效能是不是高一倍？</p>
</li>
<li><p>系统性能是否高一倍？</p>
</li>
<li><p>问题反馈环比下降是否能好一倍？</p>
</li>
<li><p>之前因架构不能支持的功能，是否可以支持到？（从这个角度看，不只是好一倍，从零到一是好了无数倍）</p>
</li>
</ul>
<p>好一倍是对<strong>必须有大幅改变才值得大幅变更</strong>的粗略量化描述，不要因为好一点就换掉现有东西，只有在强很多的情况下才值得去做。</p>
<p>当我们不知道要还是不要的时候，应该果断的选择不要，至少是暂时不要，直到我们清楚的知道为什么要。</p>
<h2 id="19-不要重复你自己"><a href="#19-不要重复你自己" class="headerlink" title="19. 不要重复你自己"></a>19. 不要重复你自己</h2><p>很经典的 <strong>“DRY”原则</strong> ，它可能是所有编程原则里最根本的原则之一。</p>
<p><strong>重复就是浪费</strong>，每一行代码都会被维护到，而且可能是未来 <code>buy</code> 的潜在来源，重复的代码会带来代码库的膨胀，增加了复杂度，维护成本也会增加。<code>DRY</code>的要求是在一个系统内，每一块知识必须有一个单一的、明确的、权威的表示。</p>
<p><strong>将重复的过程调用自动化</strong>， 人工测试很慢，所以需要自动化测试。代码集成部署手工完成耗时且容易出错，所以有了流水线。但凡需要重复多次的工作，都需要自动化。如果经常需要处理相同格式的文本，就写一个包含 <code>cut</code> <code>grep</code> <code>sed</code> <code>awk</code> 的脚本帮你完成工作。</p>
<blockquote>
<p>重复不仅仅指代码的重复，即使代码不同但实现了同样的功能，或者不同代码在描述同一个领域模型概念，都是重复。</p>
</blockquote>
<h2 id="20-没有高手神话，请把问题描述清楚"><a href="#20-没有高手神话，请把问题描述清楚" class="headerlink" title="20. 没有高手神话，请把问题描述清楚"></a>20. 没有高手神话，请把问题描述清楚</h2><p>如果有人问你这样一个问题：</p>
<blockquote>
<ol>
<li>我碰到一个 <code>XYZ</code>异常，你知道问题出在哪里吗？</li>
<li>创作者不能发文了，帮忙看一下吧？</li>
<li>群里发你一个没有上下文的截图，或者群里@你，帮忙看一下？<br>上面的问题反馈还是一个完整的句子，有的同学在提问问题的时候都没有断句和标点，甚至有错别字和倒装句。遇到这种情况真的是苦不堪言。</li>
</ol>
</blockquote>
<p>你一定会满头问号，心里怒骂：没有堆栈信息、没有错误日志、没有信息上下文、没有 <code>trace</code>链路信息，没有对比截图，仅凭一句话就寻求你的帮助，希望你能看懂并且帮助解决问题。对方真是把你当成神仙高手了。</p>
<p>提出问题的人可能更适合回答问题，因为他有更多的信息上下文。<strong>所以在对别人提出问题的时候，请把问题使用对方能理解的词汇和方式描述清楚，并且把上下文也要描述清楚</strong></p>
<blockquote>
<p>总之一句话：会问问题。</p>
</blockquote>
<h2 id="21-学习新语言"><a href="#21-学习新语言" class="headerlink" title="21. 学习新语言"></a>21. 学习新语言</h2><p>我们假设一种场景：</p>
<ol>
<li><p>业务同学讲了十分钟，提出一个需求，期望能对产品做一个改进，进而吸引更多的用户使用</p>
</li>
<li><p>业务人员在讲的过程中，技术同学在草纸上画起了神秘的符号</p>
</li>
<li><p>业务同学讲完之后，一脸期待的看着技术同学</p>
</li>
<li><p>技术同学低声讨论完之后，走到白板旁，一边画着表示多个系统视图的复杂图形，一边以复杂的技术术语解释为何没有对系统做出重大升级之前无法支持这个需求</p>
</li>
<li><p>业务人员很震惊，如此简单的需求竟然需要如此巨大的改变</p>
</li>
<li><p>技术同学也很诧异，业务同学竟然没理解他刚绘制的架构改动才能适配需求</p>
</li>
</ol>
<p>问题就在这里，没有一方能够理解另一方的意思，也不理解对方言论中的一些词语。相比和自己不同的人，和与自己类似的人相处会更舒服，这是基本的心理学规律。</p>
<blockquote>
<p>新语言并不特指明编程语言，更多的是不同的领域概念。<br>想象一下，如果技术同学能够以业务同学可理解的术语向其解释其中的问题，业务同学以技术能够理解的术语解释业务上的问题，上述情况将会有改观。</p>
</blockquote>
<p>同样的道理，如果我们和交易同学有合作就应该去了解交易系统的概念和规则。如果和推荐系统合作就该去了解一下召回&#x2F;倒排等概念，买一本推荐系统的书从头看一下，可以不求甚解。如果和会计系统合作就应该了解“有借必有贷，借贷必相等”，甚至可以去考一些会计基础证书。</p>
<p>问出好问题，很重要。只有先让对方听懂你的问题，你才能有好答案。不要沉浸在自己的世界中和别人沟通，要使用别人能理解的词汇去描述或回答问题，以及描述问题的时候携带必要的上下文，尽量给对方提供舒服的交流环境。</p>
<blockquote>
<p>学了新的语言，才能够使用别人能听懂的语言沟通，这样提出的问题才能得到更好的解答</p>
</blockquote>
<h2 id="22-加班加点，事倍功半"><a href="#22-加班加点，事倍功半" class="headerlink" title="22. 加班加点，事倍功半"></a>22. 加班加点，事倍功半</h2><p>专业编程不像几公里的全力奔跑，目标就如宽阔马路的尽头一样清晰可见。而更像黑暗中进行的马拉松，你只有一张粗略的地图。如果蒙头奔着一个方向跑下去，则不太可能成功。你需要保持一个可接受的步速，当你对自己所处的位置有了更多了解之后，就调整你的行程。</p>
<p>同时，你还需要时间来持续学习，让你的专业领域知识保持最新。因此，你不能把你的晚上、周末、假期都用在加班上。<strong>对工作的准备和持续学习才是职业生涯的核心部分</strong>。</p>
<p>工作要像一个专业人员一样：充分准备、付诸实施、观察、反省和改变。专注于你的项目，竭尽所能找到灵活的解决方案，提高你的技能，反省思考你正在做的事情，然后调整自己的行为，不要把所有精力都放在全力奔跑上。</p>
<p><strong>放下鼠标，离开键盘，去走一走，让大脑做一些与创造性相关的事情，听听音乐，休息一下。<strong>只有当你离开电脑之后，你才会发现你解决问题的第一次尝试并不是解决问题的最佳方案。这也是</strong>设计两次</strong>的最佳时机。</p>
<blockquote>
<p>在开发项目时，你会对问题领域了解的越来越多，并有望找到更高效的途径。为了避免无效工作，你必须有足够的时间去观察你手头上的工作，思考你所看到的情况，并随时调整你的行为</p>
</blockquote>
<h2 id="23-数据是核心"><a href="#23-数据是核心" class="headerlink" title="23. 数据是核心"></a>23. 数据是核心</h2><p>从站在更远的角度来看，系统一般都是操作数据的工具而已。无论代码量级有多少，处于核心地位的永远是<strong>数据</strong>。而且相对于繁杂的代码，把注意力集中到底层小的多的基本数据集上，会更容易一些。<strong>数据要比代码更加精炼，也更好理解</strong>。要想读懂程序，最为困难的就是厘清哪些数据之间是相互关联的。</p>
<p>就如同代码的优化升级都还好做一些，但涉及到数据结构的变化，解决起来就会困难得多，要考虑双写、同步、迁移、一致性。数据构成了系统的核心，数据是系统中最重要的部分，代码可以是一坨便便，但数据一定要清晰且合理。所以对数据的设计要给予足够的重视。</p>
<blockquote>
<ol>
<li>系统设计时优先考虑数据模型的设计</li>
<li>上手新服务时优先查看数据存储的实现。这时候如果是非结构化存储，会有理解成本。</li>
</ol>
</blockquote>
<h2 id="24-根据投资回报率-ROI-进行决策"><a href="#24-根据投资回报率-ROI-进行决策" class="headerlink" title="24. 根据投资回报率(ROI)进行决策"></a>24. 根据投资回报率(ROI)进行决策</h2><p>测试是一件 <code>ROI</code>很高的事情，投入 4 个小时时间编写测试用例。却可以省下 8 小时的问题排查时间，投资回报率高达 200%。</p>
<p>如果发布上架对投资方是至关重要的，那么花费半年才能得到的完美系统相比于花费 2 个月的 <code>MVP</code>版本”，<code>ROI</code>就要低很多。发布了能用的版本，根据用户反馈适当调整，更能活得下去。</p>
<p>系统的升级改造，主要是时间投入和预计收益是否能适当。即使一个系统架构不佳，但是修改频率很低，那么就可以先放置在那里，不去管他。先把时间投入其他重要事情上，如果没有其他事情可做，那另当别论。</p>
<h2 id="25-拉伸关键维度，发现设计中的不足"><a href="#25-拉伸关键维度，发现设计中的不足" class="headerlink" title="25. 拉伸关键维度，发现设计中的不足"></a>25. 拉伸关键维度，发现设计中的不足</h2><p>我们的设计一般都是基于当前需求、当前熟悉的技术、预期的数据量和当前性能要求等实现的。</p>
<p>在设计的时候，我们可以来拉伸解决方案中的关键维度，看看哪些方面会遭到破坏。比如，如果用户量越来越多，当前系统是否能承载；如果每天处理的交易数据量越来越多，是当前的十倍百倍会如何；如果数据必须要保存 6 个月而非一周时，当前存储是否满足；通过这些手段，这样我们就能发现设计的不足。</p>
<p>我们暂且简称其为<strong>无限法</strong>，即尝试系统中的关键维度扩展到无限大的时候，会发生什么。</p>
<p>设计归设计，实现归实现。当前数据量少，我们可以用 <code>mysql</code>实现检索，但是要保留以后检索维度或数据增多之后替换成 <code>ES</code>或者搜索中台的能力。对 <code>ES</code>操作的代码在这次实现中可能一行都不会写，但是要保证以后对于扩展来说是易于添加&#x2F;切换的。</p>
<p>这就涉及到对好代码(好设计)的标准，就是：<strong>是否能轻而易举的修改它</strong>。主要有两点：</p>
<ul>
<li><p>可读性：首先要读懂，才能谈修改</p>
</li>
<li><p>可扩展性：能够轻易找到修改点，快速做出修改。并且基于开闭原则，只增加而不修改原有逻辑才能避免引入错误</p>
</li>
</ul>
<h2 id="26-编码标准的自动化"><a href="#26-编码标准的自动化" class="headerlink" title="26. 编码标准的自动化"></a>26. 编码标准的自动化</h2><p>研发流程中引入 <code>CI/CD</code>流水线，代码不符合规范就要中止流程，测试覆盖度不够或者测试用例失败都要中止流水线。代码检查和发布上线都使用流水线完成，<strong>避免人为犯错的机会</strong>。</p>
<p>越早发现 <code>bug</code>，修复成本越低。因此我们希望在编码阶段就能发现 <code>bug</code>，发现 <code>bug</code>的方式就是自动化测试，可能是单测，也可能是接口测试。</p>
<p>要想实现这个目标，需要：</p>
<ol>
<li><p>非侵入式的测试框架。</p>
</li>
<li><p>一套能够与测试相协调的部署系统。</p>
</li>
<li><p>团队成员乐于执行自动化测试。</p>
</li>
<li><p>编写易于测试的代码 - 无状态的代码更易于测试。</p>
</li>
</ol>
<blockquote>
<p>让所有的线上变更都走流程，即使你认为加行日志不会有问题，但是也可能会因为空指针而 <code>core dump</code></p>
</blockquote>
<h2 id="27-靠谱和信用是我们的资产"><a href="#27-靠谱和信用是我们的资产" class="headerlink" title="27. 靠谱和信用是我们的资产"></a>27. 靠谱和信用是我们的资产</h2><p>工作就是树立个人影响力的过程，不管是你写的代码多牛逼，解决了多复杂的问题，这是一方面。但总还是有一些软素质直接影响评价和定位。比如：</p>
<ul>
<li><p>问题的解决者和终结者：只会抱怨还是低头去解决问题</p>
</li>
<li><p>事事有回应，不管办不办得成：不丢消息不只是对系统的要求，也是对个人的要求</p>
</li>
<li><p>不要有太强自尊心，别人跟你你说：你这个实现有问题。第一反应不要是反驳</p>
</li>
<li><p>如果不能如期履行承诺，请尽快告知受影响的人，以便对方调整计划。完不成不是一件丢人的事情。</p>
</li>
<li><p>把事做完：系统重构新功能上线，老服务没下掉是否是完成？</p>
</li>
</ul>
<h2 id="28-应该了解设计模式的原则"><a href="#28-应该了解设计模式的原则" class="headerlink" title="28. 应该了解设计模式的原则"></a>28. 应该了解设计模式的原则</h2><p>这些原则耳熟能详，但是是否做到了呢。过上几个月问一下自己。</p>
<ul>
<li><p><code>SOLID</code>原则：单一职责、开闭原则、里氏替换、接口隔离、依赖倒置</p>
</li>
<li><p><code>KISS</code>原则：<code>Keep it Simple and Stupid</code>、<code>Keep it Short and Simple</code>、<code>Keep it Simple and Straightforward</code></p>
</li>
<li><p><code>DRY</code>: <code>Dont Repeat Yourself</code></p>
</li>
<li><p><code>LoD</code>原则: 最少依赖</p>
</li>
</ul>
<h2 id="29-了解-Unix-哲学"><a href="#29-了解-Unix-哲学" class="headerlink" title="29. 了解 Unix 哲学"></a>29. 了解 Unix 哲学</h2><ul>
<li><p>模块原则：使用简洁的接口拼合简单的部件，每个模块做好一件事儿。</p>
</li>
<li><p>清晰原则：清晰胜于机巧，代码首先是给人看的，其次才是给机器执行。</p>
</li>
<li><p>组合原则：设计时考虑拼接组合，类似于 把每个程序都写成过滤器：和 shell 管道一样，一个函数的输出可以作为另一个函数的输入。能组合就不要耦合。</p>
</li>
<li><p>分离原则：策略同机制分离，接口同引擎分离。</p>
</li>
<li><p>简洁原则：设计要简洁，复杂度能低则低。</p>
</li>
<li><p>吝啬原则：除非确无它法，不要编写庞大的程序。避免不必要的代码和逻辑，保持精简。</p>
</li>
<li><p>透明性原则：设计要可见，以便审查和调试。</p>
</li>
<li><p>健壮原则：健壮源于透明与简洁。</p>
</li>
<li><p>表示原则：把知识叠入数据以求逻辑质朴而健壮。代码的复杂度应该在数据中，而不是代码中。</p>
</li>
<li><p>通俗原则：接口设计避免标新立异。“+”应该永远表示加法，而不是除法。</p>
</li>
<li><p>缄默原则：如果程序没什么好说的，就保持沉默。</p>
</li>
<li><p>补救原则：出现异常时，马上退出并给出足量错误信息。</p>
</li>
<li><p>经济原则：宁花机器一分，不花程序员一秒。</p>
</li>
<li><p>生成原则：避免手撕, 尽量编写程序去生成程序。</p>
</li>
<li><p>优化原则：雕琢前先要有原型，跑之前先学会走。</p>
</li>
<li><p>扩展原则：设计着眼未来，未来总比预想来得快。</p>
</li>
</ul>
<h2 id="30-在责备别人之前先检查自己的代码"><a href="#30-在责备别人之前先检查自己的代码" class="headerlink" title="30. 在责备别人之前先检查自己的代码"></a>30. 在责备别人之前先检查自己的代码</h2><p>开发人员通常难以相信自己的代码会出错，绝不可能出错，即使出错了，也必定是编译器出问题了。</p>
<p>如果我们使用的工具&#x2F;库&#x2F;框架是被广泛使用的，那就几乎没有理由怀疑它会出错。如果发生了不符合预期的表现，那就首先怀疑自己的代码：用桩代码进行调用调试，围绕可疑代码编写测试用例，检查版本库版本号，检查配置是否生效等等。</p>
<p>如果其他人报告说有问题，而你无法复现的时候，那就走过去看看他们到底是怎么使用的。他们可能进行了你未曾预料的操作，或者采用了不同的操作次序。排除掉一切不可能之后，剩下的即使多么不可能，即使你的代码看起来没问题，也只能是真相。</p>
<h2 id="31-编写具有领域语言的代码"><a href="#31-编写具有领域语言的代码" class="headerlink" title="31. 编写具有领域语言的代码"></a>31. 编写具有领域语言的代码</h2><p>先看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;int, Map&lt;int, int&gt;&gt; portfolioIdsByTraderId</span><br><span class="line"></span><br><span class="line">If portfolioIdsByTraderId.get(trader.getId()).containsKey(portfolio.getId()))</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看起来像是从 <code>trader</code>中取 <code>id</code>，然后用它从一个….，最后看起来是判断<code>protfolio</code>的<code>id</code>是否存在于这个<code>map</code>中，那<code>portfolioIdsByTraderId</code> 是什么结构呢？ 奥，它是个嵌套<code>map</code>…<br>从另一份代码中，你看到的是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If trader.canView(portfolio) &#123;…&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种情况下就不用挠头，也不需要知道它内部到底嵌套了几层 <code>map</code>，因为那是 <code>trader</code> 的事情，与你无关。<br>我们努力的方向就是将现实世界映射到有限的数据结构中，这就需要用户自定义类型，如果你的代码中包含类似 <code>trader</code> <code>portfolio</code> 这样的概念，你就可以使用他们的名称来建模，而不是使用基本数据类型复杂嵌套表述你的目的。不要有基本类型偏执，不要固执的非要使用基本类型(如 <code>map</code> <code>array</code> <code>int</code>等).</p>
<p>否则你怎么知道这个 <code>int</code> 代表了 <code>trader</code>，那个 <code>int</code> 代表了 <code>portfolio</code>，这就是在用一种加密的方式在编码，除了你自己，谁都看不懂；可能明天你自己也就看不懂了。</p>
<h2 id="32-最好的注释是软件设计架构文档"><a href="#32-最好的注释是软件设计架构文档" class="headerlink" title="32. 最好的注释是软件设计架构文档"></a>32. 最好的注释是软件设计架构文档</h2><p>前面有两条我们提到，又要好好写注释，又不要写注释。因为注释和注释是不一样的，有意义的注释永不嫌多。从另一个角度看，代码里的注释都是补丁，是碎片化的，局部的注释很难推导模块整体的顺序及耦合关系。整个项目思路的重要性远甚于穿插在代码中的几行注释。</p>
<p><strong>文档建设和技术沉淀比我们想象的还重要</strong>，刨除交接困难的影响以外，没有文档建设的项目一般在质量和架构上也会是一团乱麻。就跟没有地图的路径规划一样，没有文档建设的系统发展也会极度追求短期效益，最终走向混乱。</p>
<p>好好写代码注释，说明你是一个不错的程序员。能够好好写架构设计文档，把各个模块交代清楚，同时代码内也能好好写注释，那应该可以“配享太庙”。</p>
<h2 id="33-越早写单元测试越好"><a href="#33-越早写单元测试越好" class="headerlink" title="33. 越早写单元测试越好"></a>33. 越早写单元测试越好</h2><p>测试既可以是狭义的单元测试，也可以是广义上的功能回归测试。除了单测对质量的保障之外，单元测试还能够帮助改善设计，因为不好测试的代码一般意味着代码结构不好; 可能是引用了全局变量、也没有使用依赖注入导致难以 <code>mock</code>、也可能是没有针对接口编程；函数内部随意调用 <code>time.Now()</code> 导致测试用例不稳定等等。</p>
<p>问题越早被发现，解决的成本越低。单元测试是最早能发现 <code>bug</code>的手段，同时测试带来的边际成本是很低的，只要写一次，就可以永远为你保驾护航。</p>
<h2 id="34-没有什么能够阻止项目成为屎山"><a href="#34-没有什么能够阻止项目成为屎山" class="headerlink" title="34. 没有什么能够阻止项目成为屎山"></a>34. 没有什么能够阻止项目成为屎山</h2><p>你的代码会随着新功能的增加，以及新技术组件的引入，技术债务会逐步推迟并积压，代码也一定会腐化，因此没有什么办法能够阻止项目腐化，最终也一定会变为我们曾经厌恶的屎山。不如我们妥协一些，接受它最终会变烂，只不过要让他腐化的慢一些、再慢一些。以及做好故障隔离，即使部分功能出了问题能够限制影响范围，不要雪崩。</p>
<p>让服务稳定的跑起来，支撑业务迭代的时间久一些，即使出了问题也能及时发现并解决，把日志打清楚清楚一些，定位能够快一些。做到这些，就善莫大焉了。永远没有正确架构，你永远无法偿还完所有的技术债务，如同你永远不会设计出完美的界面，请避开完美主义的陷阱，永远没有完美的代码，能够满足当前需求，又为未来不管是自己还是他人留有扩展空间，就很好了。</p>
<p>我们能够做到的就是<strong>减缓复杂度增长的速率</strong>，通过 <strong>《整洁的代码》</strong>、<strong>《整洁的架构》<strong>和持续的</strong>《重构》</strong>，达成写更好的代码的目的。如果项目经过几年不得不重构了，那就大胆推倒重构好了，因为架构都是对过去经验的总结，无法预计业务的发展，站在几年后的时间节点回看，重构也是自然的，要不然怎么创造新的岗位需求呢。</p>
<h2 id="35-要不断学习，有针对性的勤加练习"><a href="#35-要不断学习，有针对性的勤加练习" class="headerlink" title="35. 要不断学习，有针对性的勤加练习"></a>35. 要不断学习，有针对性的勤加练习</h2><p>互联网唯一不变的就是变化，技术的出现也是层出不穷，知识的边界也是难以触达。唯有不断学习，才能保持竞争力。</p>
<p>阅读书籍、博客和技术网站，或者为自己找一个导师，可能 <code>Ta</code> 并不承认有你这个学生。导师可能是技术领域的大拿，也可能是网上的技术博主，或者是线下技术分享的讲师，也可能是 <code>B</code>站上的一位 <code>Up</code>主。他是谁并不重要，重要的是你要从他身上学到些什么。</p>
<p>了解你使用的框架和库。读懂他们的运作方式，你会使用的更好。这样你也有机会看到那些聪明人写下的并经过审查的代码。</p>
<p>当你犯错时，或者修复一个 <code>bug</code>，或者遇到问题时，试着真正去了解到底发生了什么。多问几次 <code>Why</code>，多往下追问几层，尝试找出根本原因。</p>
<p>多分享，只有分享才会让你真正了解底层原理。准备分享的过程就是不断追问自己为什么的过程，正因为你不知道为什么所以才需要查阅更多的资料来搞明白。能讲出来三分，说明你懂了七分。</p>
<p>学习那些能改变你的东西，学习那些能改变你行为的东西。不要在自己已经是专家的领域重复练习，去完成那些超出你当前能力的任务，尽力去做，在任务中和任务后分析你的表现情况，改正错误。</p>
<p>保持好奇，尝试找到自己的一套方法论，这套方法论能指导你快速了解一个复杂软件具体是如何工作的；</p>
<p>定期复盘，复盘不只再揭开伤疤撒把盐，更多看是否能有新的输入。比如上个季度做的一项工作，如果以现在的视角再去看一下，是否可以做的更好。</p>
<p>学习的东西不一定跟技术相关，如果学习所从事领域的知识可能会让你更好的理解需求、更快的解决业务问题、甚至于能够让你更充足更开心，那就去做。</p>
<p>不要把所有时间都用在工作, 毕竟，工作之余就应该是生活。</p>
<h2 id="36-了解你的局限性"><a href="#36-了解你的局限性" class="headerlink" title="36. 了解你的局限性"></a>36. 了解你的局限性</h2><p>你的资源是有限的：</p>
<ul>
<li><p>你每天只有 8 个小时时间可以用在工作上</p>
</li>
<li><p>你跑步的上限是 10KM，最多打球 2 小时，否则容易拉伤</p>
</li>
<li><p>你的系统只能承载一万的 <code>QPS</code></p>
</li>
<li><p>你的机器带宽只是千兆网卡, 只能传输 100MB</p>
</li>
<li><p>你的系统核心数据结构的时间复杂度是 <code>O(n)</code>的</p>
</li>
<li><p><code>RAM</code>一次读取需要耗时 <code>20ns</code>，而磁盘的一次随机读需要耗时 <code>10ms</code>，从北京到广州的耗时是 <code>50ms</code></p>
</li>
</ul>
<p>这些都是你的局限，除了知道你能做什么以外，还应该了解你的局限。这样你才能在排期协调、系统容量预估、大事件扩容、数据量增多导致的查询性能下降等方面做得更好。</p>
<h2 id="37-使接口易于正确使用，难于错误使用"><a href="#37-使接口易于正确使用，难于错误使用" class="headerlink" title="37. 使接口易于正确使用，难于错误使用"></a>37. 使接口易于正确使用，难于错误使用</h2><p>接口的存在是为了方便使用者，而不是接口实现者。如果一个接口需要在<strong>好实现但是不好使用</strong>和<strong>好使用但是不好实现</strong>上选择的话，请毫不犹豫的选择后者。</p>
<p>比如输入框需要用户输入日期，用户怎么知道输入格式呢，用户输入错误该怎么提醒呢？ 更合理的应该提供一个日历组件，用户直接选择就好了，不需要输入。</p>
<p>一个功能需要调用方必须先调用 A()初始化，再调用 B()，最后再调用 C()清理。那何不如把这些步骤封装起来直接暴露一个接口呢。</p>
<p> </p>
<h2 id="38-编写代码就像余生都要对他负责一样"><a href="#38-编写代码就像余生都要对他负责一样" class="headerlink" title="38. 编写代码就像余生都要对他负责一样"></a>38. 编写代码就像余生都要对他负责一样</h2><blockquote>
<p>想象一个场景：你已经跳槽来公司 3 年了，一个工作日的下午你正在会议室开会，突然接到了上家公司的一个电话，需要你解释一下你所设计的系统架构决策点是什么，以及这个函数为什么要这样写。<br>是不是会很痛苦也会很无奈</p>
</blockquote>
<p>我们进行的所有的工作最终都会落实在代码上，如果你写过的代码需要你对他负责一辈子，那么你会逼着三年前的自己好好命名，将大函数拆分成易于理解的小函数。将类和包结构好好组织，写好注释，并测试自己的代码。设计文档也会好好写，技术债务也会清理而不会任其堆积。因为余生你都需要对这份代码负责，所以你只能将它变得更优美、更灵活、更高效。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
